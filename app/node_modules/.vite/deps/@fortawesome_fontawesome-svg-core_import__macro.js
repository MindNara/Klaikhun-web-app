import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-TFWDKVI3.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports, module) {
    "use strict";
    var os = require_os();
    module.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports, module) {
    module.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports, module) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module.exports = win32.parse;
    else
      module.exports = posix.parse;
    module.exports.posix = posix.parse;
    module.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports, module) {
    var path = require_path();
    var parse3 = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse3(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse3(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports, module) {
    module.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports, module) {
    "use strict";
    var has = require_src();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore(x, nodeVersion) {
      return has(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports, module) {
    var fs = require_fs();
    var getHomedir = require_homedir();
    var path = require_path();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolve27(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports, module) {
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data = require_core2();
    var core2 = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core2[mod] = versionIncluded(data[mod]);
      }
    }
    var mod;
    module.exports = core2;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports, module) {
    var isCoreModule = require_is_core_module();
    module.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports, module) {
    var isCore = require_is_core_module();
    var fs = require_fs();
    var path = require_path();
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports, module) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module.exports = async;
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/resolve-from/index.js"(exports, module) {
    "use strict";
    var path = require_path();
    var Module = require_module();
    var fs = require_fs();
    var resolveFrom = (fromDir, moduleId, silent) => {
      if (typeof fromDir !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDir = fs.realpathSync(fromDir);
      } catch (err) {
        if (err.code === "ENOENT") {
          fromDir = path.resolve(fromDir);
        } else if (silent) {
          return null;
        } else {
          throw err;
        }
      }
      const fromFile = path.join(fromDir, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (err) {
          return null;
        }
      }
      return resolveFileName();
    };
    module.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);
    module.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);
  }
});

// node_modules/callsites/index.js
var require_callsites = __commonJS({
  "node_modules/callsites/index.js"(exports, module) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module.exports = callsites;
    module.exports.default = callsites;
  }
});

// node_modules/parent-module/index.js
var require_parent_module = __commonJS({
  "node_modules/parent-module/index.js"(exports, module) {
    "use strict";
    var callsites = require_callsites();
    module.exports = (filepath) => {
      const stacks = callsites();
      if (!filepath) {
        return stacks[2].getFileName();
      }
      let seenVal = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== "string") {
          continue;
        }
        if (parentFilepath === filepath) {
          seenVal = true;
          continue;
        }
        if (parentFilepath === "module.js") {
          continue;
        }
        if (seenVal && parentFilepath !== filepath) {
          return parentFilepath;
        }
      }
    };
  }
});

// node_modules/import-fresh/index.js
var require_import_fresh = __commonJS({
  "node_modules/import-fresh/index.js"(exports, module) {
    "use strict";
    var path = require_path();
    var resolveFrom = require_resolve_from();
    var parentModule = require_parent_module();
    module.exports = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError("Expected a string");
      }
      const parentPath = parentModule(__filename);
      const cwd = parentPath ? path.dirname(parentPath) : __dirname;
      const filePath = resolveFrom(cwd, moduleId);
      const oldModule = __require.cache[filePath];
      if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while (i--) {
          if (oldModule.parent.children[i].id === filePath) {
            oldModule.parent.children.splice(i, 1);
          }
        }
      }
      delete __require.cache[filePath];
      const parent = __require.cache[parentPath];
      return parent === void 0 ? __require(filePath) : parent.require(filePath);
    };
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    "use strict";
    module.exports = function isArrayish(obj) {
      if (!obj) {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
    };
  }
});

// node_modules/error-ex/index.js
var require_error_ex = __commonJS({
  "node_modules/error-ex/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var isArrayish = require_is_arrayish();
    var errorEx = function errorEx2(name, properties) {
      if (!name || name.constructor !== String) {
        properties = name || {};
        name = Error.name;
      }
      var errorExError = function ErrorEXError(message) {
        if (!this) {
          return new ErrorEXError(message);
        }
        message = message instanceof Error ? message.message : message || this.message;
        Error.call(this, message);
        Error.captureStackTrace(this, errorExError);
        this.name = name;
        Object.defineProperty(this, "message", {
          configurable: true,
          enumerable: false,
          get: function() {
            var newMessage = message.split(/\r?\n/g);
            for (var key in properties) {
              if (!properties.hasOwnProperty(key)) {
                continue;
              }
              var modifier = properties[key];
              if ("message" in modifier) {
                newMessage = modifier.message(this[key], newMessage) || newMessage;
                if (!isArrayish(newMessage)) {
                  newMessage = [newMessage];
                }
              }
            }
            return newMessage.join("\n");
          },
          set: function(v) {
            message = v;
          }
        });
        var overwrittenStack = null;
        var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
        var stackGetter = stackDescriptor.get;
        var stackValue = stackDescriptor.value;
        delete stackDescriptor.value;
        delete stackDescriptor.writable;
        stackDescriptor.set = function(newstack) {
          overwrittenStack = newstack;
        };
        stackDescriptor.get = function() {
          var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
          if (!overwrittenStack) {
            stack[0] = this.name + ": " + this.message;
          }
          var lineCount = 1;
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("line" in modifier) {
              var line = modifier.line(this[key]);
              if (line) {
                stack.splice(lineCount++, 0, "    " + line);
              }
            }
            if ("stack" in modifier) {
              modifier.stack(this[key], stack);
            }
          }
          return stack.join("\n");
        };
        Object.defineProperty(this, "stack", stackDescriptor);
      };
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(errorExError.prototype, Error.prototype);
        Object.setPrototypeOf(errorExError, Error);
      } else {
        util.inherits(errorExError, Error);
      }
      return errorExError;
    };
    errorEx.append = function(str, def) {
      return {
        message: function(v, message) {
          v = v || def;
          if (v) {
            message[0] += " " + str.replace("%s", v.toString());
          }
          return message;
        }
      };
    };
    errorEx.line = function(str, def) {
      return {
        line: function(v) {
          v = v || def;
          if (v) {
            return str.replace("%s", v.toString());
          }
          return null;
        }
      };
    };
    module.exports = errorEx;
  }
});

// node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS({
  "node_modules/json-parse-even-better-errors/index.js"(exports, module) {
    "use strict";
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return "0x" + (h.length % 2 ? "0" : "") + h;
    };
    var parseError = (e, txt, context) => {
      if (!txt) {
        return {
          message: e.message + " while parsing empty string",
          position: 0
        };
      }
      const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
      const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
      const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
      if (errIdx !== null && errIdx !== void 0) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        const slice = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
        const near = txt === slice ? "" : "near ";
        return {
          message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
          position: errIdx
        };
      } else {
        return {
          message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
          position: 0
        };
      }
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context, caller) {
        context = context || 20;
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var kIndent = Symbol.for("indent");
    var kNewline = Symbol.for("newline");
    var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
    var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var parseJson = (txt, reviver, context) => {
      const parseText = stripBOM(txt);
      context = context || 20;
      try {
        const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
        const result = JSON.parse(parseText, reviver);
        if (result && typeof result === "object") {
          result[kNewline] = newline;
          result[kIndent] = indent;
        }
        return result;
      } catch (e) {
        if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
          const isEmptyArray = Array.isArray(txt) && txt.length === 0;
          throw Object.assign(new TypeError(
            `Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`
          ), {
            code: "EJSONPARSE",
            systemError: e
          });
        }
        throw new JSONParseError(e, parseText, context, parseJson);
      }
    };
    var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
    module.exports = parseJson;
    parseJson.JSONParseError = JSONParseError;
    parseJson.noExceptions = (txt, reviver) => {
      try {
        return JSON.parse(stripBOM(txt), reviver);
      } catch (e) {
      }
    };
  }
});

// node_modules/lines-and-columns/build/index.js
var require_build = __commonJS({
  "node_modules/lines-and-columns/build/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.LinesAndColumns = void 0;
    var LF = "\n";
    var CR = "\r";
    var LinesAndColumns = (
      /** @class */
      function() {
        function LinesAndColumns2(string2) {
          this.string = string2;
          var offsets = [0];
          for (var offset = 0; offset < string2.length; ) {
            switch (string2[offset]) {
              case LF:
                offset += LF.length;
                offsets.push(offset);
                break;
              case CR:
                offset += CR.length;
                if (string2[offset] === LF) {
                  offset += LF.length;
                }
                offsets.push(offset);
                break;
              default:
                offset++;
                break;
            }
          }
          this.offsets = offsets;
        }
        LinesAndColumns2.prototype.locationForIndex = function(index) {
          if (index < 0 || index > this.string.length) {
            return null;
          }
          var line = 0;
          var offsets = this.offsets;
          while (offsets[line + 1] <= index) {
            line++;
          }
          var column = index - offsets[line];
          return { line, column };
        };
        LinesAndColumns2.prototype.indexForLocation = function(location) {
          var line = location.line, column = location.column;
          if (line < 0 || line >= this.offsets.length) {
            return null;
          }
          if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
          }
          return this.offsets[line] + column;
        };
        LinesAndColumns2.prototype.lengthOfLine = function(line) {
          var offset = this.offsets[line];
          var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
          return nextOffset - offset;
        };
        return LinesAndColumns2;
      }()
    );
    exports.LinesAndColumns = LinesAndColumns;
    exports["default"] = LinesAndColumns;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
    var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set2) {
      let pos = 65536;
      for (let i = 0, length = set2.length; i < length; i += 2) {
        pos += set2[i];
        if (pos > code)
          return false;
        pos += set2[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/chalk/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_browser().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = highlight;
    exports.getChalk = getChalk;
    exports.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib();
    var _chalk = require_chalk();
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return !!_chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      return options.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const chalk = getChalk(options);
        const defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;
    var _highlight = require_lib2();
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string2) => {
        return highlighted ? chalkFn(string2) : string2;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/parse-json/index.js
var require_parse_json = __commonJS({
  "node_modules/parse-json/index.js"(exports, module) {
    "use strict";
    var errorEx = require_error_ex();
    var fallback = require_json_parse_even_better_errors();
    var { default: LinesAndColumns } = require_build();
    var { codeFrameColumns } = require_lib3();
    var JSONError = errorEx("JSONError", {
      fileName: errorEx.append("in %s"),
      codeFrame: errorEx.append("\n\n%s\n")
    });
    var parseJson = (string2, reviver, filename) => {
      if (typeof reviver === "string") {
        filename = reviver;
        reviver = null;
      }
      try {
        try {
          return JSON.parse(string2, reviver);
        } catch (error) {
          fallback(string2, reviver);
          throw error;
        }
      } catch (error) {
        error.message = error.message.replace(/\n/g, "");
        const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
        const jsonError = new JSONError(error);
        if (filename) {
          jsonError.fileName = filename;
        }
        if (indexMatch && indexMatch.length > 0) {
          const lines = new LinesAndColumns(string2);
          const index = Number(indexMatch[1]);
          const location = lines.locationForIndex(index);
          const codeFrame = codeFrameColumns(
            string2,
            { start: { line: location.line + 1, column: location.column + 1 } },
            { highlightCode: true }
          );
          jsonError.codeFrame = codeFrame;
        }
        throw jsonError;
      }
    };
    parseJson.JSONError = JSONError;
    module.exports = parseJson;
  }
});

// node_modules/yaml/browser/dist/PlainValue-b8036b75.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = o[Symbol.iterator]();
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function findLineStarts(src) {
  var ls = [0];
  var offset = src.indexOf("\n");
  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf("\n", offset);
  }
  return ls;
}
function getSrcInfo(cst) {
  var lineStarts, src;
  if (typeof cst === "string") {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst))
      cst = cst[0];
    if (cst && cst.context) {
      if (!cst.lineStarts)
        cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }
  return {
    lineStarts,
    src
  };
}
function getLinePos(offset, cst) {
  if (typeof offset !== "number" || offset < 0)
    return null;
  var _getSrcInfo = getSrcInfo(cst), lineStarts = _getSrcInfo.lineStarts, src = _getSrcInfo.src;
  if (!lineStarts || !src || offset > src.length)
    return null;
  for (var i = 0; i < lineStarts.length; ++i) {
    var start = lineStarts[i];
    if (offset < start) {
      return {
        line: i,
        col: offset - lineStarts[i - 1] + 1
      };
    }
    if (offset === start)
      return {
        line: i + 1,
        col: 1
      };
  }
  var line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
function getLine(line, cst) {
  var _getSrcInfo2 = getSrcInfo(cst), lineStarts = _getSrcInfo2.lineStarts, src = _getSrcInfo2.src;
  if (!lineStarts || !(line >= 1) || line > lineStarts.length)
    return null;
  var start = lineStarts[line - 1];
  var end = lineStarts[line];
  while (end && end > start && src[end - 1] === "\n") {
    --end;
  }
  return src.slice(start, end);
}
function getPrettyContext(_ref, cst) {
  var start = _ref.start, end = _ref.end;
  var maxWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80;
  var src = getLine(start.line, cst);
  if (!src)
    return null;
  var col = start.col;
  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + "…";
    } else {
      var halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth)
        src = src.substr(0, col + halfWidth - 1) + "…";
      col -= src.length - maxWidth;
      src = "…" + src.substr(1 - maxWidth);
    }
  }
  var errLen = 1;
  var errEnd = "";
  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = "…";
    }
  }
  var offset = col > 1 ? " ".repeat(col - 1) : "";
  var err = "^".repeat(errLen);
  return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
}
var Char, Type, defaultTagPrefix, defaultTags, Range, Node, YAMLError, YAMLReferenceError, YAMLSemanticError, YAMLSyntaxError, YAMLWarning, PlainValue;
var init_PlainValue_b8036b75 = __esm({
  "node_modules/yaml/browser/dist/PlainValue-b8036b75.js"() {
    Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    defaultTagPrefix = "tag:yaml.org,2002:";
    defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    Range = function() {
      function Range2(start, end) {
        _classCallCheck(this, Range2);
        this.start = start;
        this.end = end || start;
      }
      _createClass(Range2, [{
        key: "isEmpty",
        value: function isEmpty() {
          return typeof this.start !== "number" || !this.end || this.end <= this.start;
        }
        /**
         * Set `origStart` and `origEnd` to point to the original source range for
         * this node, which may differ due to dropped CR characters.
         *
         * @param {number[]} cr - Positions of dropped CR characters
         * @param {number} offset - Starting index of `cr` from the last call
         * @returns {number} - The next offset, matching the one found for `origStart`
         */
      }, {
        key: "setOrigRange",
        value: function setOrigRange(cr, offset) {
          var start = this.start, end = this.end;
          if (cr.length === 0 || end <= cr[0]) {
            this.origStart = start;
            this.origEnd = end;
            return offset;
          }
          var i = offset;
          while (i < cr.length) {
            if (cr[i] > start)
              break;
            else
              ++i;
          }
          this.origStart = start + i;
          var nextOffset = i;
          while (i < cr.length) {
            if (cr[i] >= end)
              break;
            else
              ++i;
          }
          this.origEnd = end + i;
          return nextOffset;
        }
      }], [{
        key: "copy",
        value: function copy(orig) {
          return new Range2(orig.start, orig.end);
        }
      }]);
      return Range2;
    }();
    Node = function() {
      function Node4(type, props, context) {
        _classCallCheck(this, Node4);
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type;
        this.value = null;
      }
      _createClass(Node4, [{
        key: "getPropValue",
        value: function getPropValue(idx, key, skipKey) {
          if (!this.context)
            return null;
          var src = this.context.src;
          var prop = this.props[idx];
          return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
        }
      }, {
        key: "anchor",
        get: function get() {
          for (var i = 0; i < this.props.length; ++i) {
            var anchor = this.getPropValue(i, Char.ANCHOR, true);
            if (anchor != null)
              return anchor;
          }
          return null;
        }
      }, {
        key: "comment",
        get: function get() {
          var comments = [];
          for (var i = 0; i < this.props.length; ++i) {
            var comment = this.getPropValue(i, Char.COMMENT, true);
            if (comment != null)
              comments.push(comment);
          }
          return comments.length > 0 ? comments.join("\n") : null;
        }
      }, {
        key: "commentHasRequiredWhitespace",
        value: function commentHasRequiredWhitespace(start) {
          var src = this.context.src;
          if (this.header && start === this.header.end)
            return false;
          if (!this.valueRange)
            return false;
          var end = this.valueRange.end;
          return start !== end || Node4.atBlank(src, end - 1);
        }
      }, {
        key: "hasComment",
        get: function get() {
          if (this.context) {
            var src = this.context.src;
            for (var i = 0; i < this.props.length; ++i) {
              if (src[this.props[i].start] === Char.COMMENT)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "hasProps",
        get: function get() {
          if (this.context) {
            var src = this.context.src;
            for (var i = 0; i < this.props.length; ++i) {
              if (src[this.props[i].start] !== Char.COMMENT)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "includesTrailingLines",
        get: function get() {
          return false;
        }
      }, {
        key: "jsonLike",
        get: function get() {
          var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
          return jsonLikeTypes.indexOf(this.type) !== -1;
        }
      }, {
        key: "rangeAsLinePos",
        get: function get() {
          if (!this.range || !this.context)
            return void 0;
          var start = getLinePos(this.range.start, this.context.root);
          if (!start)
            return void 0;
          var end = getLinePos(this.range.end, this.context.root);
          return {
            start,
            end
          };
        }
      }, {
        key: "rawValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          return this.context.src.slice(start, end);
        }
      }, {
        key: "tag",
        get: function get() {
          for (var i = 0; i < this.props.length; ++i) {
            var tag = this.getPropValue(i, Char.TAG, false);
            if (tag != null) {
              if (tag[1] === "<") {
                return {
                  verbatim: tag.slice(2, -1)
                };
              } else {
                var _tag$match = tag.match(/^(.*!)([^!]*)$/), _tag$match2 = _slicedToArray(_tag$match, 3);
                _tag$match2[0];
                var handle = _tag$match2[1], suffix = _tag$match2[2];
                return {
                  handle,
                  suffix
                };
              }
            }
          }
          return null;
        }
      }, {
        key: "valueRangeContainsNewline",
        get: function get() {
          if (!this.valueRange || !this.context)
            return false;
          var _this$valueRange2 = this.valueRange, start = _this$valueRange2.start, end = _this$valueRange2.end;
          var src = this.context.src;
          for (var i = start; i < end; ++i) {
            if (src[i] === "\n")
              return true;
          }
          return false;
        }
      }, {
        key: "parseComment",
        value: function parseComment(start) {
          var src = this.context.src;
          if (src[start] === Char.COMMENT) {
            var end = Node4.endOfLine(src, start + 1);
            var commentRange = new Range(start, end);
            this.props.push(commentRange);
            return end;
          }
          return start;
        }
        /**
         * Populates the `origStart` and `origEnd` values of all ranges for this
         * node. Extended by child classes to handle descendant nodes.
         *
         * @param {number[]} cr - Positions of dropped CR characters
         * @param {number} offset - Starting index of `cr` from the last call
         * @returns {number} - The next offset, matching the one found for `origStart`
         */
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          if (this.range)
            offset = this.range.setOrigRange(cr, offset);
          if (this.valueRange)
            this.valueRange.setOrigRange(cr, offset);
          this.props.forEach(function(prop) {
            return prop.setOrigRange(cr, offset);
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, range = this.range, value = this.value;
          if (value != null)
            return value;
          var str = src.slice(range.start, range.end);
          return Node4.addStringTerminator(src, range.end, str);
        }
      }], [{
        key: "addStringTerminator",
        value: function addStringTerminator(src, offset, str) {
          if (str[str.length - 1] === "\n")
            return str;
          var next = Node4.endOfWhiteSpace(src, offset);
          return next >= src.length || src[next] === "\n" ? str + "\n" : str;
        }
        // ^(---|...)
      }, {
        key: "atDocumentBoundary",
        value: function atDocumentBoundary(src, offset, sep) {
          var ch0 = src[offset];
          if (!ch0)
            return true;
          var prev = src[offset - 1];
          if (prev && prev !== "\n")
            return false;
          if (sep) {
            if (ch0 !== sep)
              return false;
          } else {
            if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
              return false;
          }
          var ch1 = src[offset + 1];
          var ch2 = src[offset + 2];
          if (ch1 !== ch0 || ch2 !== ch0)
            return false;
          var ch3 = src[offset + 3];
          return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
        }
      }, {
        key: "endOfIdentifier",
        value: function endOfIdentifier(src, offset) {
          var ch = src[offset];
          var isVerbatim = ch === "<";
          var notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
          while (ch && notOk.indexOf(ch) === -1) {
            ch = src[offset += 1];
          }
          if (isVerbatim && ch === ">")
            offset += 1;
          return offset;
        }
      }, {
        key: "endOfIndent",
        value: function endOfIndent(src, offset) {
          var ch = src[offset];
          while (ch === " ") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "endOfLine",
        value: function endOfLine(src, offset) {
          var ch = src[offset];
          while (ch && ch !== "\n") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "endOfWhiteSpace",
        value: function endOfWhiteSpace(src, offset) {
          var ch = src[offset];
          while (ch === "	" || ch === " ") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "startOfLine",
        value: function startOfLine(src, offset) {
          var ch = src[offset - 1];
          if (ch === "\n")
            return offset;
          while (ch && ch !== "\n") {
            ch = src[offset -= 1];
          }
          return offset + 1;
        }
        /**
         * End of indentation, or null if the line's indent level is not more
         * than `indent`
         *
         * @param {string} src
         * @param {number} indent
         * @param {number} lineStart
         * @returns {?number}
         */
      }, {
        key: "endOfBlockIndent",
        value: function endOfBlockIndent(src, indent, lineStart) {
          var inEnd = Node4.endOfIndent(src, lineStart);
          if (inEnd > lineStart + indent) {
            return inEnd;
          } else {
            var wsEnd = Node4.endOfWhiteSpace(src, inEnd);
            var ch = src[wsEnd];
            if (!ch || ch === "\n")
              return wsEnd;
          }
          return null;
        }
      }, {
        key: "atBlank",
        value: function atBlank(src, offset, endAsBlank) {
          var ch = src[offset];
          return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
        }
      }, {
        key: "nextNodeIsIndented",
        value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
          if (!ch || indentDiff < 0)
            return false;
          if (indentDiff > 0)
            return true;
          return indicatorAsIndent && ch === "-";
        }
        // should be at line or string end, or at next non-whitespace char
      }, {
        key: "normalizeOffset",
        value: function normalizeOffset(src, offset) {
          var ch = src[offset];
          return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node4.endOfWhiteSpace(src, offset);
        }
        // fold single newline into space, multiple newlines to N - 1 newlines
        // presumes src[offset] === '\n'
      }, {
        key: "foldNewline",
        value: function foldNewline(src, offset, indent) {
          var inCount = 0;
          var error = false;
          var fold = "";
          var ch = src[offset + 1];
          while (ch === " " || ch === "	" || ch === "\n") {
            switch (ch) {
              case "\n":
                inCount = 0;
                offset += 1;
                fold += "\n";
                break;
              case "	":
                if (inCount <= indent)
                  error = true;
                offset = Node4.endOfWhiteSpace(src, offset + 2) - 1;
                break;
              case " ":
                inCount += 1;
                offset += 1;
                break;
            }
            ch = src[offset + 1];
          }
          if (!fold)
            fold = " ";
          if (ch && inCount <= indent)
            error = true;
          return {
            fold,
            offset,
            error
          };
        }
      }]);
      return Node4;
    }();
    YAMLError = function(_Error) {
      _inherits(YAMLError2, _Error);
      var _super = _createSuper(YAMLError2);
      function YAMLError2(name, source, message) {
        var _this;
        _classCallCheck(this, YAMLError2);
        if (!message || !(source instanceof Node))
          throw new Error("Invalid arguments for new ".concat(name));
        _this = _super.call(this);
        _this.name = name;
        _this.message = message;
        _this.source = source;
        return _this;
      }
      _createClass(YAMLError2, [{
        key: "makePretty",
        value: function makePretty() {
          if (!this.source)
            return;
          this.nodeType = this.source.type;
          var cst = this.source.context && this.source.context.root;
          if (typeof this.offset === "number") {
            this.range = new Range(this.offset, this.offset + 1);
            var start = cst && getLinePos(this.offset, cst);
            if (start) {
              var end = {
                line: start.line,
                col: start.col + 1
              };
              this.linePos = {
                start,
                end
              };
            }
            delete this.offset;
          } else {
            this.range = this.source.range;
            this.linePos = this.source.rangeAsLinePos;
          }
          if (this.linePos) {
            var _this$linePos$start = this.linePos.start, line = _this$linePos$start.line, col = _this$linePos$start.col;
            this.message += " at line ".concat(line, ", column ").concat(col);
            var ctx = cst && getPrettyContext(this.linePos, cst);
            if (ctx)
              this.message += ":\n\n".concat(ctx, "\n");
          }
          delete this.source;
        }
      }]);
      return YAMLError2;
    }(_wrapNativeSuper(Error));
    YAMLReferenceError = function(_YAMLError) {
      _inherits(YAMLReferenceError2, _YAMLError);
      var _super2 = _createSuper(YAMLReferenceError2);
      function YAMLReferenceError2(source, message) {
        _classCallCheck(this, YAMLReferenceError2);
        return _super2.call(this, "YAMLReferenceError", source, message);
      }
      return YAMLReferenceError2;
    }(YAMLError);
    YAMLSemanticError = function(_YAMLError2) {
      _inherits(YAMLSemanticError2, _YAMLError2);
      var _super3 = _createSuper(YAMLSemanticError2);
      function YAMLSemanticError2(source, message) {
        _classCallCheck(this, YAMLSemanticError2);
        return _super3.call(this, "YAMLSemanticError", source, message);
      }
      return YAMLSemanticError2;
    }(YAMLError);
    YAMLSyntaxError = function(_YAMLError3) {
      _inherits(YAMLSyntaxError2, _YAMLError3);
      var _super4 = _createSuper(YAMLSyntaxError2);
      function YAMLSyntaxError2(source, message) {
        _classCallCheck(this, YAMLSyntaxError2);
        return _super4.call(this, "YAMLSyntaxError", source, message);
      }
      return YAMLSyntaxError2;
    }(YAMLError);
    YAMLWarning = function(_YAMLError4) {
      _inherits(YAMLWarning2, _YAMLError4);
      var _super5 = _createSuper(YAMLWarning2);
      function YAMLWarning2(source, message) {
        _classCallCheck(this, YAMLWarning2);
        return _super5.call(this, "YAMLWarning", source, message);
      }
      return YAMLWarning2;
    }(YAMLError);
    PlainValue = function(_Node) {
      _inherits(PlainValue2, _Node);
      var _super = _createSuper(PlainValue2);
      function PlainValue2() {
        _classCallCheck(this, PlainValue2);
        return _super.apply(this, arguments);
      }
      _createClass(PlainValue2, [{
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var src = this.context.src;
          var ch = src[end - 1];
          while (start < end && (ch === "\n" || ch === "	" || ch === " ")) {
            ch = src[--end - 1];
          }
          var str = "";
          for (var i = start; i < end; ++i) {
            var _ch = src[i];
            if (_ch === "\n") {
              var _Node$foldNewline = Node.foldNewline(src, i, -1), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset;
              str += fold;
              i = offset;
            } else if (_ch === " " || _ch === "	") {
              var wsStart = i;
              var next = src[i + 1];
              while (i < end && (next === " " || next === "	")) {
                i += 1;
                next = src[i + 1];
              }
              if (next !== "\n")
                str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
            } else {
              str += _ch;
            }
          }
          var ch0 = src[start];
          switch (ch0) {
            case "	": {
              var msg = "Plain value cannot start with a tab character";
              var errors = [new YAMLSemanticError(this, msg)];
              return {
                errors,
                str
              };
            }
            case "@":
            case "`": {
              var _msg = "Plain value cannot start with reserved character ".concat(ch0);
              var _errors = [new YAMLSemanticError(this, _msg)];
              return {
                errors: _errors,
                str
              };
            }
            default:
              return str;
          }
        }
      }, {
        key: "parseBlockValue",
        value: function parseBlockValue(start) {
          var _this$context = this.context, indent = _this$context.indent, inFlow = _this$context.inFlow, src = _this$context.src;
          var offset = start;
          var valueEnd = start;
          for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
            if (Node.atDocumentBoundary(src, offset + 1))
              break;
            var end = Node.endOfBlockIndent(src, indent, offset + 1);
            if (end === null || src[end] === "#")
              break;
            if (src[end] === "\n") {
              offset = end;
            } else {
              valueEnd = PlainValue2.endOfLine(src, end, inFlow);
              offset = valueEnd;
            }
          }
          if (this.valueRange.isEmpty())
            this.valueRange.start = start;
          this.valueRange.end = valueEnd;
          return valueEnd;
        }
        /**
         * Parses a plain value from the source
         *
         * Accepted forms are:
         * ```
         * #comment
         *
         * first line
         *
         * first line #comment
         *
         * first line
         * block
         * lines
         *
         * #comment
         * block
         * lines
         * ```
         * where block lines are empty or have an indent level greater than `indent`.
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar, may be `\n`
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var inFlow = context.inFlow, src = context.src;
          var offset = start;
          var ch = src[offset];
          if (ch && ch !== "#" && ch !== "\n") {
            offset = PlainValue2.endOfLine(src, start, inFlow);
          }
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          if (!this.hasComment || this.valueRange.isEmpty()) {
            offset = this.parseBlockValue(offset);
          }
          return offset;
        }
      }], [{
        key: "endOfLine",
        value: function endOfLine(src, start, inFlow) {
          var ch = src[start];
          var offset = start;
          while (ch && ch !== "\n") {
            if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
              break;
            var next = src[offset + 1];
            if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
              break;
            if ((ch === " " || ch === "	") && next === "#")
              break;
            offset += 1;
            ch = next;
          }
          return offset;
        }
      }]);
      return PlainValue2;
    }(Node);
  }
});

// node_modules/yaml/browser/dist/parse-cst.js
function grabCollectionEndComments(node) {
  var cnode = node;
  while (cnode instanceof CollectionItem) {
    cnode = cnode.node;
  }
  if (!(cnode instanceof Collection))
    return null;
  var len = cnode.items.length;
  var ci = -1;
  for (var i = len - 1; i >= 0; --i) {
    var n = cnode.items[i];
    if (n.type === Type.COMMENT) {
      var _n$context = n.context, indent = _n$context.indent, lineStart = _n$context.lineStart;
      if (indent > 0 && n.range.start >= lineStart + indent)
        break;
      ci = i;
    } else if (n.type === Type.BLANK_LINE)
      ci = i;
    else
      break;
  }
  if (ci === -1)
    return null;
  var ca = cnode.items.splice(ci, len - ci);
  var prevEnd = ca[0].range.start;
  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd)
      cnode.valueRange.end = prevEnd;
    if (cnode === node)
      break;
    cnode = cnode.context.parent;
  }
  return ca;
}
function createNewNode(type, props) {
  switch (type) {
    case Type.ALIAS:
      return new Alias(type, props);
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
      return new BlockValue(type, props);
    case Type.FLOW_MAP:
    case Type.FLOW_SEQ:
      return new FlowCollection(type, props);
    case Type.MAP_KEY:
    case Type.MAP_VALUE:
    case Type.SEQ_ITEM:
      return new CollectionItem(type, props);
    case Type.COMMENT:
    case Type.PLAIN:
      return new PlainValue(type, props);
    case Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);
    case Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);
    default:
      return null;
  }
}
function parse(src) {
  var cr = [];
  if (src.indexOf("\r") !== -1) {
    src = src.replace(/\r\n?/g, function(match, offset2) {
      if (match.length > 1)
        cr.push(offset2);
      return "\n";
    });
  }
  var documents = [];
  var offset = 0;
  do {
    var doc = new Document();
    var context = new ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);
  documents.setOrigRanges = function() {
    if (cr.length === 0)
      return false;
    for (var i = 1; i < cr.length; ++i) {
      cr[i] -= i;
    }
    var crOffset = 0;
    for (var _i = 0; _i < documents.length; ++_i) {
      crOffset = documents[_i].setOrigRanges(cr, crOffset);
    }
    cr.splice(0, cr.length);
    return true;
  };
  documents.toString = function() {
    return documents.join("...\n");
  };
  return documents;
}
var BlankLine, CollectionItem, Comment, Collection, Directive, Document, Alias, Chomp, BlockValue, FlowCollection, QuoteDouble, QuoteSingle, ParseContext;
var init_parse_cst = __esm({
  "node_modules/yaml/browser/dist/parse-cst.js"() {
    init_PlainValue_b8036b75();
    BlankLine = function(_Node) {
      _inherits(BlankLine2, _Node);
      var _super = _createSuper(BlankLine2);
      function BlankLine2() {
        _classCallCheck(this, BlankLine2);
        return _super.call(this, Type.BLANK_LINE);
      }
      _createClass(BlankLine2, [{
        key: "includesTrailingLines",
        get: function get() {
          return true;
        }
        /**
         * Parses a blank line from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first \n character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          this.range = new Range(start, start + 1);
          return start + 1;
        }
      }]);
      return BlankLine2;
    }(Node);
    CollectionItem = function(_Node) {
      _inherits(CollectionItem2, _Node);
      var _super = _createSuper(CollectionItem2);
      function CollectionItem2(type, props) {
        var _this;
        _classCallCheck(this, CollectionItem2);
        _this = _super.call(this, type, props);
        _this.node = null;
        return _this;
      }
      _createClass(CollectionItem2, [{
        key: "includesTrailingLines",
        get: function get() {
          return !!this.node && this.node.includesTrailingLines;
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var atLineStart = context.atLineStart, lineStart = context.lineStart;
          if (!atLineStart && this.type === Type.SEQ_ITEM)
            this.error = new YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
          var indent = atLineStart ? start - lineStart : context.indent;
          var offset = Node.endOfWhiteSpace(src, start + 1);
          var ch = src[offset];
          var inlineComment = ch === "#";
          var comments = [];
          var blankLine = null;
          while (ch === "\n" || ch === "#") {
            if (ch === "#") {
              var _end = Node.endOfLine(src, offset + 1);
              comments.push(new Range(offset, _end));
              offset = _end;
            } else {
              atLineStart = true;
              lineStart = offset + 1;
              var wsEnd = Node.endOfWhiteSpace(src, lineStart);
              if (src[wsEnd] === "\n" && comments.length === 0) {
                blankLine = new BlankLine();
                lineStart = blankLine.parse({
                  src
                }, lineStart);
              }
              offset = Node.endOfIndent(src, lineStart);
            }
            ch = src[offset];
          }
          if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
            this.node = parseNode({
              atLineStart,
              inCollection: false,
              indent,
              lineStart,
              parent: this
            }, offset);
          } else if (ch && lineStart > start + 1) {
            offset = lineStart - 1;
          }
          if (this.node) {
            if (blankLine) {
              var items = context.parent.items || context.parent.contents;
              if (items)
                items.push(blankLine);
            }
            if (comments.length)
              Array.prototype.push.apply(this.props, comments);
            offset = this.node.range.end;
          } else {
            if (inlineComment) {
              var c = comments[0];
              this.props.push(c);
              offset = c.end;
            } else {
              offset = Node.endOfLine(src, start + 1);
            }
          }
          var end = this.node ? this.node.valueRange.end : offset;
          this.valueRange = new Range(start, end);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(CollectionItem2.prototype), "setOrigRanges", this).call(this, cr, offset);
          return this.node ? this.node.setOrigRanges(cr, offset) : offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, node = this.node, range = this.range, value = this.value;
          if (value != null)
            return value;
          var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
          return Node.addStringTerminator(src, range.end, str);
        }
      }]);
      return CollectionItem2;
    }(Node);
    Comment = function(_Node) {
      _inherits(Comment2, _Node);
      var _super = _createSuper(Comment2);
      function Comment2() {
        _classCallCheck(this, Comment2);
        return _super.call(this, Type.COMMENT);
      }
      _createClass(Comment2, [{
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var offset = this.parseComment(start);
          this.range = new Range(start, offset);
          return offset;
        }
      }]);
      return Comment2;
    }(Node);
    Collection = function(_Node) {
      _inherits(Collection3, _Node);
      var _super = _createSuper(Collection3);
      function Collection3(firstItem) {
        var _this;
        _classCallCheck(this, Collection3);
        _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);
        for (var i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            _this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            var itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        _this.items = [firstItem];
        var ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(_this.items, ec);
        return _this;
      }
      _createClass(Collection3, [{
        key: "includesTrailingLines",
        get: function get() {
          return this.items.length > 0;
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var lineStart = Node.startOfLine(src, start);
          var firstItem = this.items[0];
          firstItem.context.parent = this;
          this.valueRange = Range.copy(firstItem.valueRange);
          var indent = firstItem.range.start - firstItem.context.lineStart;
          var offset = start;
          offset = Node.normalizeOffset(src, offset);
          var ch = src[offset];
          var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;
          var prevIncludesTrailingLines = false;
          while (ch) {
            while (ch === "\n" || ch === "#") {
              if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
                var blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                this.valueRange.end = offset;
                if (offset >= src.length) {
                  ch = null;
                  break;
                }
                this.items.push(blankLine);
                offset -= 1;
              } else if (ch === "#") {
                if (offset < lineStart + indent && !Collection3.nextContentHasIndent(src, offset, indent)) {
                  return offset;
                }
                var comment = new Comment();
                offset = comment.parse({
                  indent,
                  lineStart,
                  src
                }, offset);
                this.items.push(comment);
                this.valueRange.end = offset;
                if (offset >= src.length) {
                  ch = null;
                  break;
                }
              }
              lineStart = offset + 1;
              offset = Node.endOfIndent(src, lineStart);
              if (Node.atBlank(src, offset)) {
                var wsEnd = Node.endOfWhiteSpace(src, offset);
                var next = src[wsEnd];
                if (!next || next === "\n" || next === "#") {
                  offset = wsEnd;
                }
              }
              ch = src[offset];
              atLineStart = true;
            }
            if (!ch) {
              break;
            }
            if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
              if (offset < lineStart + indent) {
                if (lineStart > start)
                  offset = lineStart;
                break;
              } else if (!this.error) {
                var msg = "All collection items must start at the same column";
                this.error = new YAMLSyntaxError(this, msg);
              }
            }
            if (firstItem.type === Type.SEQ_ITEM) {
              if (ch !== "-") {
                if (lineStart > start)
                  offset = lineStart;
                break;
              }
            } else if (ch === "-" && !this.error) {
              var _next = src[offset + 1];
              if (!_next || _next === "\n" || _next === "	" || _next === " ") {
                var _msg = "A collection cannot be both a mapping and a sequence";
                this.error = new YAMLSyntaxError(this, _msg);
              }
            }
            var node = parseNode({
              atLineStart,
              inCollection: true,
              indent,
              lineStart,
              parent: this
            }, offset);
            if (!node)
              return offset;
            this.items.push(node);
            this.valueRange.end = node.valueRange.end;
            offset = Node.normalizeOffset(src, node.range.end);
            ch = src[offset];
            atLineStart = false;
            prevIncludesTrailingLines = node.includesTrailingLines;
            if (ch) {
              var ls = offset - 1;
              var prev = src[ls];
              while (prev === " " || prev === "	") {
                prev = src[--ls];
              }
              if (prev === "\n") {
                lineStart = ls + 1;
                atLineStart = true;
              }
            }
            var ec = grabCollectionEndComments(node);
            if (ec)
              Array.prototype.push.apply(this.items, ec);
          }
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(Collection3.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.items.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, items = this.items, range = this.range, value = this.value;
          if (value != null)
            return value;
          var str = src.slice(range.start, items[0].range.start) + String(items[0]);
          for (var i = 1; i < items.length; ++i) {
            var item = items[i];
            var _item$context = item.context, atLineStart = _item$context.atLineStart, indent = _item$context.indent;
            if (atLineStart)
              for (var _i = 0; _i < indent; ++_i) {
                str += " ";
              }
            str += String(item);
          }
          return Node.addStringTerminator(src, range.end, str);
        }
      }], [{
        key: "nextContentHasIndent",
        value: function nextContentHasIndent(src, offset, indent) {
          var lineStart = Node.endOfLine(src, offset) + 1;
          offset = Node.endOfWhiteSpace(src, lineStart);
          var ch = src[offset];
          if (!ch)
            return false;
          if (offset >= lineStart + indent)
            return true;
          if (ch !== "#" && ch !== "\n")
            return false;
          return Collection3.nextContentHasIndent(src, offset, indent);
        }
      }]);
      return Collection3;
    }(Node);
    Directive = function(_Node) {
      _inherits(Directive2, _Node);
      var _super = _createSuper(Directive2);
      function Directive2() {
        var _this;
        _classCallCheck(this, Directive2);
        _this = _super.call(this, Type.DIRECTIVE);
        _this.name = null;
        return _this;
      }
      _createClass(Directive2, [{
        key: "parameters",
        get: function get() {
          var raw = this.rawValue;
          return raw ? raw.trim().split(/[ \t]+/) : [];
        }
      }, {
        key: "parseName",
        value: function parseName(start) {
          var src = this.context.src;
          var offset = start;
          var ch = src[offset];
          while (ch && ch !== "\n" && ch !== "	" && ch !== " ") {
            ch = src[offset += 1];
          }
          this.name = src.slice(start, offset);
          return offset;
        }
      }, {
        key: "parseParameters",
        value: function parseParameters(start) {
          var src = this.context.src;
          var offset = start;
          var ch = src[offset];
          while (ch && ch !== "\n" && ch !== "#") {
            ch = src[offset += 1];
          }
          this.valueRange = new Range(start, offset);
          return offset;
        }
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var offset = this.parseName(start + 1);
          offset = this.parseParameters(offset);
          offset = this.parseComment(offset);
          this.range = new Range(start, offset);
          return offset;
        }
      }]);
      return Directive2;
    }(Node);
    Document = function(_Node) {
      _inherits(Document3, _Node);
      var _super = _createSuper(Document3);
      function Document3() {
        var _this;
        _classCallCheck(this, Document3);
        _this = _super.call(this, Type.DOCUMENT);
        _this.directives = null;
        _this.contents = null;
        _this.directivesEndMarker = null;
        _this.documentEndMarker = null;
        return _this;
      }
      _createClass(Document3, [{
        key: "parseDirectives",
        value: function parseDirectives2(start) {
          var src = this.context.src;
          this.directives = [];
          var atLineStart = true;
          var hasDirectives = false;
          var offset = start;
          while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {
            offset = Document3.startCommentOrEndBlankLine(src, offset);
            switch (src[offset]) {
              case "\n":
                if (atLineStart) {
                  var blankLine = new BlankLine();
                  offset = blankLine.parse({
                    src
                  }, offset);
                  if (offset < src.length) {
                    this.directives.push(blankLine);
                  }
                } else {
                  offset += 1;
                  atLineStart = true;
                }
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.directives.push(comment);
                  atLineStart = false;
                }
                break;
              case "%":
                {
                  var directive = new Directive();
                  offset = directive.parse({
                    parent: this,
                    src
                  }, offset);
                  this.directives.push(directive);
                  hasDirectives = true;
                  atLineStart = false;
                }
                break;
              default:
                if (hasDirectives) {
                  this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
                } else if (this.directives.length > 0) {
                  this.contents = this.directives;
                  this.directives = [];
                }
                return offset;
            }
          }
          if (src[offset]) {
            this.directivesEndMarker = new Range(offset, offset + 3);
            return offset + 3;
          }
          if (hasDirectives) {
            this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }
          return offset;
        }
      }, {
        key: "parseContents",
        value: function parseContents2(start) {
          var _this$context = this.context, parseNode = _this$context.parseNode, src = _this$context.src;
          if (!this.contents)
            this.contents = [];
          var lineStart = start;
          while (src[lineStart - 1] === "-") {
            lineStart -= 1;
          }
          var offset = Node.endOfWhiteSpace(src, start);
          var atLineStart = lineStart === start;
          this.valueRange = new Range(offset);
          while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {
            switch (src[offset]) {
              case "\n":
                if (atLineStart) {
                  var blankLine = new BlankLine();
                  offset = blankLine.parse({
                    src
                  }, offset);
                  if (offset < src.length) {
                    this.contents.push(blankLine);
                  }
                } else {
                  offset += 1;
                  atLineStart = true;
                }
                lineStart = offset;
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.contents.push(comment);
                  atLineStart = false;
                }
                break;
              default: {
                var iEnd = Node.endOfIndent(src, offset);
                var context = {
                  atLineStart,
                  indent: -1,
                  inFlow: false,
                  inCollection: false,
                  lineStart,
                  parent: this
                };
                var node = parseNode(context, iEnd);
                if (!node)
                  return this.valueRange.end = iEnd;
                this.contents.push(node);
                offset = node.range.end;
                atLineStart = false;
                var ec = grabCollectionEndComments(node);
                if (ec)
                  Array.prototype.push.apply(this.contents, ec);
              }
            }
            offset = Document3.startCommentOrEndBlankLine(src, offset);
          }
          this.valueRange.end = offset;
          if (src[offset]) {
            this.documentEndMarker = new Range(offset, offset + 3);
            offset += 3;
            if (src[offset]) {
              offset = Node.endOfWhiteSpace(src, offset);
              if (src[offset] === "#") {
                var _comment = new Comment();
                offset = _comment.parse({
                  src
                }, offset);
                this.contents.push(_comment);
              }
              switch (src[offset]) {
                case "\n":
                  offset += 1;
                  break;
                case void 0:
                  break;
                default:
                  this.error = new YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
              }
            }
          }
          return offset;
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          context.root = this;
          this.context = context;
          var src = context.src;
          var offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
          offset = this.parseDirectives(offset);
          offset = this.parseContents(offset);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(Document3.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.directives.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          if (this.directivesEndMarker)
            offset = this.directivesEndMarker.setOrigRange(cr, offset);
          this.contents.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          if (this.documentEndMarker)
            offset = this.documentEndMarker.setOrigRange(cr, offset);
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var contents = this.contents, directives = this.directives, value = this.value;
          if (value != null)
            return value;
          var str = directives.join("");
          if (contents.length > 0) {
            if (directives.length > 0 || contents[0].type === Type.COMMENT)
              str += "---\n";
            str += contents.join("");
          }
          if (str[str.length - 1] !== "\n")
            str += "\n";
          return str;
        }
      }], [{
        key: "startCommentOrEndBlankLine",
        value: function startCommentOrEndBlankLine(src, start) {
          var offset = Node.endOfWhiteSpace(src, start);
          var ch = src[offset];
          return ch === "#" || ch === "\n" ? offset : start;
        }
      }]);
      return Document3;
    }(Node);
    Alias = function(_Node) {
      _inherits(Alias3, _Node);
      var _super = _createSuper(Alias3);
      function Alias3() {
        _classCallCheck(this, Alias3);
        return _super.apply(this, arguments);
      }
      _createClass(Alias3, [{
        key: "parse",
        value: (
          /**
           * Parses an *alias from the source
           *
           * @param {ParseContext} context
           * @param {number} start - Index of first character
           * @returns {number} - Index of the character after this scalar
           */
          function parse3(context, start) {
            this.context = context;
            var src = context.src;
            var offset = Node.endOfIdentifier(src, start + 1);
            this.valueRange = new Range(start + 1, offset);
            offset = Node.endOfWhiteSpace(src, offset);
            offset = this.parseComment(offset);
            return offset;
          }
        )
      }]);
      return Alias3;
    }(Node);
    Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    BlockValue = function(_Node) {
      _inherits(BlockValue2, _Node);
      var _super = _createSuper(BlockValue2);
      function BlockValue2(type, props) {
        var _this;
        _classCallCheck(this, BlockValue2);
        _this = _super.call(this, type, props);
        _this.blockIndent = null;
        _this.chomping = Chomp.CLIP;
        _this.header = null;
        return _this;
      }
      _createClass(BlockValue2, [{
        key: "includesTrailingLines",
        get: function get() {
          return this.chomping === Chomp.KEEP;
        }
      }, {
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (this.valueRange.isEmpty())
            return "";
          var lastNewLine = null;
          var ch = src[end - 1];
          while (ch === "\n" || ch === "	" || ch === " ") {
            end -= 1;
            if (end <= start) {
              if (this.chomping === Chomp.KEEP)
                break;
              else
                return "";
            }
            if (ch === "\n")
              lastNewLine = end;
            ch = src[end - 1];
          }
          var keepStart = end + 1;
          if (lastNewLine) {
            if (this.chomping === Chomp.KEEP) {
              keepStart = lastNewLine;
              end = this.valueRange.end;
            } else {
              end = lastNewLine;
            }
          }
          var bi = indent + this.blockIndent;
          var folded = this.type === Type.BLOCK_FOLDED;
          var atStart = true;
          var str = "";
          var sep = "";
          var prevMoreIndented = false;
          for (var i = start; i < end; ++i) {
            for (var j = 0; j < bi; ++j) {
              if (src[i] !== " ")
                break;
              i += 1;
            }
            var _ch = src[i];
            if (_ch === "\n") {
              if (sep === "\n")
                str += "\n";
              else
                sep = "\n";
            } else {
              var lineEnd = Node.endOfLine(src, i);
              var line = src.slice(i, lineEnd);
              i = lineEnd;
              if (folded && (_ch === " " || _ch === "	") && i < keepStart) {
                if (sep === " ")
                  sep = "\n";
                else if (!prevMoreIndented && !atStart && sep === "\n")
                  sep = "\n\n";
                str += sep + line;
                sep = lineEnd < end && src[lineEnd] || "";
                prevMoreIndented = true;
              } else {
                str += sep + line;
                sep = folded && i < keepStart ? " " : "\n";
                prevMoreIndented = false;
              }
              if (atStart && line !== "")
                atStart = false;
            }
          }
          return this.chomping === Chomp.STRIP ? str : str + "\n";
        }
      }, {
        key: "parseBlockHeader",
        value: function parseBlockHeader(start) {
          var src = this.context.src;
          var offset = start + 1;
          var bi = "";
          while (true) {
            var ch = src[offset];
            switch (ch) {
              case "-":
                this.chomping = Chomp.STRIP;
                break;
              case "+":
                this.chomping = Chomp.KEEP;
                break;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                bi += ch;
                break;
              default:
                this.blockIndent = Number(bi) || null;
                this.header = new Range(start, offset);
                return offset;
            }
            offset += 1;
          }
        }
      }, {
        key: "parseBlockValue",
        value: function parseBlockValue(start) {
          var _this$context2 = this.context, indent = _this$context2.indent, src = _this$context2.src;
          var explicit = !!this.blockIndent;
          var offset = start;
          var valueEnd = start;
          var minBlockIndent = 1;
          for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
            offset += 1;
            if (Node.atDocumentBoundary(src, offset))
              break;
            var end = Node.endOfBlockIndent(src, indent, offset);
            if (end === null)
              break;
            var _ch2 = src[end];
            var lineIndent = end - (offset + indent);
            if (!this.blockIndent) {
              if (src[end] !== "\n") {
                if (lineIndent < minBlockIndent) {
                  var msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                  this.error = new YAMLSemanticError(this, msg);
                }
                this.blockIndent = lineIndent;
              } else if (lineIndent > minBlockIndent) {
                minBlockIndent = lineIndent;
              }
            } else if (_ch2 && _ch2 !== "\n" && lineIndent < this.blockIndent) {
              if (src[end] === "#")
                break;
              if (!this.error) {
                var _src = explicit ? "explicit indentation indicator" : "first line";
                var _msg = "Block scalars must not be less indented than their ".concat(_src);
                this.error = new YAMLSemanticError(this, _msg);
              }
            }
            if (src[end] === "\n") {
              offset = end;
            } else {
              offset = valueEnd = Node.endOfLine(src, end);
            }
          }
          if (this.chomping !== Chomp.KEEP) {
            offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
          }
          this.valueRange = new Range(start + 1, offset);
          return offset;
        }
        /**
         * Parses a block value from the source
         *
         * Accepted forms are:
         * ```
         * BS
         * block
         * lines
         *
         * BS #comment
         * block
         * lines
         * ```
         * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
         * are empty or have an indent level greater than `indent`.
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this block
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = this.parseBlockHeader(start);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          offset = this.parseBlockValue(offset);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(BlockValue2.prototype), "setOrigRanges", this).call(this, cr, offset);
          return this.header ? this.header.setOrigRange(cr, offset) : offset;
        }
      }]);
      return BlockValue2;
    }(Node);
    FlowCollection = function(_Node) {
      _inherits(FlowCollection2, _Node);
      var _super = _createSuper(FlowCollection2);
      function FlowCollection2(type, props) {
        var _this;
        _classCallCheck(this, FlowCollection2);
        _this = _super.call(this, type, props);
        _this.items = null;
        return _this;
      }
      _createClass(FlowCollection2, [{
        key: "prevNodeIsJsonLike",
        value: function prevNodeIsJsonLike() {
          var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length;
          var node = this.items[idx - 1];
          return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var indent = context.indent, lineStart = context.lineStart;
          var char = src[start];
          this.items = [{
            char,
            offset: start
          }];
          var offset = Node.endOfWhiteSpace(src, start + 1);
          char = src[offset];
          while (char && char !== "]" && char !== "}") {
            switch (char) {
              case "\n":
                {
                  lineStart = offset + 1;
                  var wsEnd = Node.endOfWhiteSpace(src, lineStart);
                  if (src[wsEnd] === "\n") {
                    var blankLine = new BlankLine();
                    lineStart = blankLine.parse({
                      src
                    }, lineStart);
                    this.items.push(blankLine);
                  }
                  offset = Node.endOfIndent(src, lineStart);
                  if (offset <= lineStart + indent) {
                    char = src[offset];
                    if (offset < lineStart + indent || char !== "]" && char !== "}") {
                      var msg = "Insufficient indentation in flow collection";
                      this.error = new YAMLSemanticError(this, msg);
                    }
                  }
                }
                break;
              case ",":
                {
                  this.items.push({
                    char,
                    offset
                  });
                  offset += 1;
                }
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.items.push(comment);
                }
                break;
              case "?":
              case ":": {
                var next = src[offset + 1];
                if (next === "\n" || next === "	" || next === " " || next === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
                char === ":" && this.prevNodeIsJsonLike()) {
                  this.items.push({
                    char,
                    offset
                  });
                  offset += 1;
                  break;
                }
              }
              default: {
                var node = parseNode({
                  atLineStart: false,
                  inCollection: false,
                  inFlow: true,
                  indent: -1,
                  lineStart,
                  parent: this
                }, offset);
                if (!node) {
                  this.valueRange = new Range(start, offset);
                  return offset;
                }
                this.items.push(node);
                offset = Node.normalizeOffset(src, node.range.end);
              }
            }
            offset = Node.endOfWhiteSpace(src, offset);
            char = src[offset];
          }
          this.valueRange = new Range(start, offset + 1);
          if (char) {
            this.items.push({
              char,
              offset
            });
            offset = Node.endOfWhiteSpace(src, offset + 1);
            offset = this.parseComment(offset);
          }
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(FlowCollection2.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.items.forEach(function(node) {
            if (node instanceof Node) {
              offset = node.setOrigRanges(cr, offset);
            } else if (cr.length === 0) {
              node.origOffset = node.offset;
            } else {
              var i = offset;
              while (i < cr.length) {
                if (cr[i] > node.offset)
                  break;
                else
                  ++i;
              }
              node.origOffset = node.offset + i;
              offset = i;
            }
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, items = this.items, range = this.range, value = this.value;
          if (value != null)
            return value;
          var nodes = items.filter(function(item) {
            return item instanceof Node;
          });
          var str = "";
          var prevEnd = range.start;
          nodes.forEach(function(node) {
            var prefix = src.slice(prevEnd, node.range.start);
            prevEnd = node.range.end;
            str += prefix + String(node);
            if (str[str.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
              prevEnd += 1;
            }
          });
          str += src.slice(prevEnd, range.end);
          return Node.addStringTerminator(src, range.end, str);
        }
      }]);
      return FlowCollection2;
    }(Node);
    QuoteDouble = function(_Node) {
      _inherits(QuoteDouble2, _Node);
      var _super = _createSuper(QuoteDouble2);
      function QuoteDouble2() {
        _classCallCheck(this, QuoteDouble2);
        return _super.apply(this, arguments);
      }
      _createClass(QuoteDouble2, [{
        key: "strValue",
        get: (
          /**
           * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
           */
          function get() {
            if (!this.valueRange || !this.context)
              return null;
            var errors = [];
            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
            if (src[end - 1] !== '"')
              errors.push(new YAMLSyntaxError(this, 'Missing closing "quote'));
            var str = "";
            for (var i = start + 1; i < end - 1; ++i) {
              var ch = src[i];
              if (ch === "\n") {
                if (Node.atDocumentBoundary(src, i + 1))
                  errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                var _Node$foldNewline = Node.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
                str += fold;
                i = offset;
                if (error)
                  errors.push(new YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
              } else if (ch === "\\") {
                i += 1;
                switch (src[i]) {
                  case "0":
                    str += "\0";
                    break;
                  case "a":
                    str += "\x07";
                    break;
                  case "b":
                    str += "\b";
                    break;
                  case "e":
                    str += "\x1B";
                    break;
                  case "f":
                    str += "\f";
                    break;
                  case "n":
                    str += "\n";
                    break;
                  case "r":
                    str += "\r";
                    break;
                  case "t":
                    str += "	";
                    break;
                  case "v":
                    str += "\v";
                    break;
                  case "N":
                    str += "";
                    break;
                  case "_":
                    str += " ";
                    break;
                  case "L":
                    str += "\u2028";
                    break;
                  case "P":
                    str += "\u2029";
                    break;
                  case " ":
                    str += " ";
                    break;
                  case '"':
                    str += '"';
                    break;
                  case "/":
                    str += "/";
                    break;
                  case "\\":
                    str += "\\";
                    break;
                  case "	":
                    str += "	";
                    break;
                  case "x":
                    str += this.parseCharCode(i + 1, 2, errors);
                    i += 2;
                    break;
                  case "u":
                    str += this.parseCharCode(i + 1, 4, errors);
                    i += 4;
                    break;
                  case "U":
                    str += this.parseCharCode(i + 1, 8, errors);
                    i += 8;
                    break;
                  case "\n":
                    while (src[i + 1] === " " || src[i + 1] === "	") {
                      i += 1;
                    }
                    break;
                  default:
                    errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
                    str += "\\" + src[i];
                }
              } else if (ch === " " || ch === "	") {
                var wsStart = i;
                var next = src[i + 1];
                while (next === " " || next === "	") {
                  i += 1;
                  next = src[i + 1];
                }
                if (next !== "\n")
                  str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
              } else {
                str += ch;
              }
            }
            return errors.length > 0 ? {
              errors,
              str
            } : str;
          }
        )
      }, {
        key: "parseCharCode",
        value: function parseCharCode(offset, length, errors) {
          var src = this.context.src;
          var cc = src.substr(offset, length);
          var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
          var code = ok ? parseInt(cc, 16) : NaN;
          if (isNaN(code)) {
            errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
            return src.substr(offset - 2, length + 2);
          }
          return String.fromCodePoint(code);
        }
        /**
         * Parses a "double quoted" value from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = QuoteDouble2.endOfQuote(src, start + 1);
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }], [{
        key: "endOfQuote",
        value: function endOfQuote(src, offset) {
          var ch = src[offset];
          while (ch && ch !== '"') {
            offset += ch === "\\" ? 2 : 1;
            ch = src[offset];
          }
          return offset + 1;
        }
      }]);
      return QuoteDouble2;
    }(Node);
    QuoteSingle = function(_Node) {
      _inherits(QuoteSingle2, _Node);
      var _super = _createSuper(QuoteSingle2);
      function QuoteSingle2() {
        _classCallCheck(this, QuoteSingle2);
        return _super.apply(this, arguments);
      }
      _createClass(QuoteSingle2, [{
        key: "strValue",
        get: (
          /**
           * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
           */
          function get() {
            if (!this.valueRange || !this.context)
              return null;
            var errors = [];
            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
            if (src[end - 1] !== "'")
              errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
            var str = "";
            for (var i = start + 1; i < end - 1; ++i) {
              var ch = src[i];
              if (ch === "\n") {
                if (Node.atDocumentBoundary(src, i + 1))
                  errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                var _Node$foldNewline = Node.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
                str += fold;
                i = offset;
                if (error)
                  errors.push(new YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
              } else if (ch === "'") {
                str += ch;
                i += 1;
                if (src[i] !== "'")
                  errors.push(new YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
              } else if (ch === " " || ch === "	") {
                var wsStart = i;
                var next = src[i + 1];
                while (next === " " || next === "	") {
                  i += 1;
                  next = src[i + 1];
                }
                if (next !== "\n")
                  str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
              } else {
                str += ch;
              }
            }
            return errors.length > 0 ? {
              errors,
              str
            } : str;
          }
        )
        /**
         * Parses a 'single quoted' value from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = QuoteSingle2.endOfQuote(src, start + 1);
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }], [{
        key: "endOfQuote",
        value: function endOfQuote(src, offset) {
          var ch = src[offset];
          while (ch) {
            if (ch === "'") {
              if (src[offset + 1] !== "'")
                break;
              ch = src[offset += 2];
            } else {
              ch = src[offset += 1];
            }
          }
          return offset + 1;
        }
      }]);
      return QuoteSingle2;
    }(Node);
    ParseContext = function() {
      function ParseContext2() {
        var _this = this;
        var orig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, atLineStart = _ref.atLineStart, inCollection = _ref.inCollection, inFlow = _ref.inFlow, indent = _ref.indent, lineStart = _ref.lineStart, parent = _ref.parent;
        _classCallCheck(this, ParseContext2);
        _defineProperty(this, "parseNode", function(overlay, start) {
          if (Node.atDocumentBoundary(_this.src, start))
            return null;
          var context = new ParseContext2(_this, overlay);
          var _context$parseProps = context.parseProps(start), props = _context$parseProps.props, type = _context$parseProps.type, valueStart = _context$parseProps.valueStart;
          var node = createNewNode(type, props);
          var offset = node.parse(context, valueStart);
          node.range = new Range(start, offset);
          if (offset <= start) {
            node.error = new Error("Node#parse consumed no characters");
            node.error.parseEnd = offset;
            node.error.source = node;
            node.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node)) {
            if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {
              node.error = new YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            var collection = new Collection(node);
            offset = collection.parse(new ParseContext2(context), offset);
            collection.range = new Range(start, offset);
            return collection;
          }
          return node;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      _createClass(ParseContext2, [{
        key: "nodeStartsCollection",
        value: function nodeStartsCollection(node) {
          var inCollection = this.inCollection, inFlow = this.inFlow, src = this.src;
          if (inCollection || inFlow)
            return false;
          if (node instanceof CollectionItem)
            return true;
          var offset = node.range.end;
          if (src[offset] === "\n" || src[offset - 1] === "\n")
            return false;
          offset = Node.endOfWhiteSpace(src, offset);
          return src[offset] === ":";
        }
        // Anchor and tag are before type, which determines the node implementation
        // class; hence this intermediate step.
      }, {
        key: "parseProps",
        value: function parseProps(offset) {
          var inFlow = this.inFlow, parent = this.parent, src = this.src;
          var props = [];
          var lineHasProps = false;
          offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);
          var ch = src[offset];
          while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === "\n") {
            if (ch === "\n") {
              var inEnd = offset;
              var lineStart = void 0;
              do {
                lineStart = inEnd + 1;
                inEnd = Node.endOfIndent(src, lineStart);
              } while (src[inEnd] === "\n");
              var indentDiff = inEnd - (lineStart + this.indent);
              var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
              if (src[inEnd] !== "#" && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
                break;
              this.atLineStart = true;
              this.lineStart = lineStart;
              lineHasProps = false;
              offset = inEnd;
            } else if (ch === Char.COMMENT) {
              var end = Node.endOfLine(src, offset + 1);
              props.push(new Range(offset, end));
              offset = end;
            } else {
              var _end = Node.endOfIdentifier(src, offset + 1);
              if (ch === Char.TAG && src[_end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
                _end = Node.endOfIdentifier(src, _end + 5);
              }
              props.push(new Range(offset, _end));
              lineHasProps = true;
              offset = Node.endOfWhiteSpace(src, _end);
            }
            ch = src[offset];
          }
          if (lineHasProps && ch === ":" && Node.atBlank(src, offset + 1, true))
            offset -= 1;
          var type = ParseContext2.parseType(src, offset, inFlow);
          return {
            props,
            type,
            valueStart: offset
          };
        }
        /**
         * Parses a node from the source
         * @param {ParseContext} overlay
         * @param {number} start - Index of first non-whitespace character for the node
         * @returns {?Node} - null if at a document boundary
         */
      }], [{
        key: "parseType",
        value: function parseType(src, offset, inFlow) {
          switch (src[offset]) {
            case "*":
              return Type.ALIAS;
            case ">":
              return Type.BLOCK_FOLDED;
            case "|":
              return Type.BLOCK_LITERAL;
            case "{":
              return Type.FLOW_MAP;
            case "[":
              return Type.FLOW_SEQ;
            case "?":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;
            case ":":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;
            case "-":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;
            case '"':
              return Type.QUOTE_DOUBLE;
            case "'":
              return Type.QUOTE_SINGLE;
            default:
              return Type.PLAIN;
          }
        }
      }]);
      return ParseContext2;
    }();
  }
});

// node_modules/yaml/browser/dist/resolveSeq-492ab440.js
function addCommentBefore(str, indent, comment) {
  if (!comment)
    return str;
  var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
  return "#".concat(cc, "\n").concat(indent).concat(str);
}
function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf("\n") === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || "", "#"));
}
function toJSON(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map(function(v, i) {
      return toJSON(v, String(i), ctx);
    });
  if (value && typeof value.toJSON === "function") {
    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor)
      ctx.onCreate = function(res2) {
        anchor.res = res2;
        delete ctx.onCreate;
      };
    var res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if ((!ctx || !ctx.keep) && typeof value === "bigint")
    return Number(value);
  return value;
}
function collectionFromPath(schema, path, value) {
  var v = value;
  for (var i = path.length - 1; i >= 0; --i) {
    var k = path[i];
    if (Number.isInteger(k) && k >= 0) {
      var a = [];
      a[k] = v;
      v = a;
    } else {
      var o = {};
      Object.defineProperty(o, k, {
        value: v,
        writable: true,
        enumerable: true,
        configurable: true
      });
      v = o;
    }
  }
  return schema.createNode(v, false);
}
function asItemIndex(key) {
  var idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function findPair(items, key) {
  var k = key instanceof Scalar ? key.value : key;
  var _iterator = _createForOfIteratorHelper(items), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it = _step.value;
      if (it instanceof Pair) {
        if (it.key === key || it.key === k)
          return it;
        if (it.key && it.key.value === k)
          return it;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return void 0;
}
function resolveScalar(str, tags2, scalarFallback) {
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, format = _step$value.format, test = _step$value.test, resolve27 = _step$value.resolve;
      if (test) {
        var match = str.match(test);
        if (match) {
          var res = resolve27.apply(null, match);
          if (!(res instanceof Scalar))
            res = new Scalar(res);
          if (format)
            res.format = format;
          return res;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (scalarFallback)
    str = scalarFallback(str);
  return new Scalar(str);
}
function foldFlowLines(text, indent, mode, _ref) {
  var indentAtStart = _ref.indentAtStart, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth, _ref$minContentWidth = _ref.minContentWidth, minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
  if (!lineWidth || lineWidth < 0)
    return text;
  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  var folds = [];
  var escapedFolds = {};
  var end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  var split = void 0;
  var prev = void 0;
  var overflow = false;
  var i = -1;
  var escStart = -1;
  var escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (var ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        var next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          var j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  var res = text.slice(0, folds[0]);
  for (var _i = 0; _i < folds.length; ++_i) {
    var fold = folds[_i];
    var _end = folds[_i + 1] || text.length;
    if (fold === 0)
      res = "\n".concat(indent).concat(text.slice(0, _end));
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += "".concat(text[fold], "\\");
      res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
    }
  }
  return res;
}
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  var limit = lineWidth - indentLength;
  var strLen = str.length;
  if (strLen <= limit)
    return false;
  for (var i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  var implicitKey = ctx.implicitKey;
  var _strOptions$doubleQuo = strOptions.doubleQuoted, jsonEncoding = _strOptions$doubleQuo.jsonEncoding, minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
  var json2 = JSON.stringify(value);
  if (jsonEncoding)
    return json2;
  var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  var str = "";
  var start = 0;
  for (var i = 0, ch = json2[i]; ch; ch = json2[++i]) {
    if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str += json2.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str += json2.slice(start, i);
            var code = json2.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json2.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json2.slice(start, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json2[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json2.slice(start) : json2;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value))
      return doubleQuotedString(value, ctx);
  } else {
    if (/[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
  }
  var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function blockString(_ref2, ctx, onComment, onChompKeep) {
  var comment = _ref2.comment, type = _ref2.type, value = _ref2.value;
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString(value, ctx);
  }
  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  var indentSize = indent ? "2" : "1";
  var literal = type === Type.BLOCK_FOLDED ? false : type === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
  var header = literal ? "|" : ">";
  if (!value)
    return header + "\n";
  var wsStart = "";
  var wsEnd = "";
  value = value.replace(/[\n\t ]*$/, function(ws) {
    var n = ws.indexOf("\n");
    if (n === -1) {
      header += "-";
    } else if (value === ws || n !== ws.length - 1) {
      header += "+";
      if (onChompKeep)
        onChompKeep();
    }
    wsEnd = ws.replace(/\n$/, "");
    return "";
  }).replace(/^[\n ]*/, function(ws) {
    if (ws.indexOf(" ") !== -1)
      header += indentSize;
    var m = ws.match(/ +$/);
    if (m) {
      wsStart = ws.slice(0, -m[0].length);
      return m[0];
    } else {
      wsStart = ws;
      return "";
    }
  });
  if (wsEnd)
    wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
  if (wsStart)
    wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));
  if (comment) {
    header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
    if (onComment)
      onComment();
  }
  if (!value)
    return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);
  if (literal) {
    value = value.replace(/\n+/g, "$&".concat(indent));
    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(indent));
  var body = foldFlowLines("".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);
  return "".concat(header, "\n").concat(indent).concat(body);
}
function plainString(item, ctx, onComment, onChompKeep) {
  var comment = item.comment, type = item.type, value = item.value;
  var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, inFlow = ctx.inFlow;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Type.PLAIN && value.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  var str = value.replace(/\n+/g, "$&\n".concat(indent));
  if (actualString) {
    var tags2 = ctx.doc.schema.tags;
    var resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
    if (typeof resolved !== "string")
      return doubleQuotedString(value, ctx);
  }
  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
  if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
    if (onComment)
      onComment();
    return addCommentBefore(body, indent, comment);
  }
  return body;
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  var defaultType = strOptions.defaultType;
  var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
  var _item = item, type = _item.type, value = _item.value;
  if (typeof value !== "string") {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }
  var _stringify = function _stringify2(_type) {
    switch (_type) {
      case Type.BLOCK_FOLDED:
      case Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);
      case Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);
      case Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);
      case Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  if (type !== Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    type = Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {
    type = Type.QUOTE_DOUBLE;
  }
  var res = _stringify(type);
  if (res === null) {
    res = _stringify(defaultType);
    if (res === null)
      throw new Error("Unsupported default string type ".concat(defaultType));
  }
  return res;
}
function stringifyNumber(_ref) {
  var format = _ref.format, minFractionDigits = _ref.minFractionDigits, tag = _ref.tag, value = _ref.value;
  if (typeof value === "bigint")
    return String(value);
  if (!isFinite(value))
    return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
  var n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    var i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    var d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0) {
      n += "0";
    }
  }
  return n;
}
function checkFlowCollectionEnd(errors, cst) {
  var char, name;
  switch (cst.type) {
    case Type.FLOW_MAP:
      char = "}";
      name = "flow map";
      break;
    case Type.FLOW_SEQ:
      char = "]";
      name = "flow sequence";
      break;
    default:
      errors.push(new YAMLSemanticError(cst, "Not a flow collection!?"));
      return;
  }
  var lastItem;
  for (var i = cst.items.length - 1; i >= 0; --i) {
    var item = cst.items[i];
    if (!item || item.type !== Type.COMMENT) {
      lastItem = item;
      break;
    }
  }
  if (lastItem && lastItem.char !== char) {
    var msg = "Expected ".concat(name, " to end with ").concat(char);
    var err;
    if (typeof lastItem.offset === "number") {
      err = new YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end)
        err.offset = lastItem.range.end - lastItem.range.start;
    }
    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment) {
  var prev = comment.context.src[comment.range.start - 1];
  if (prev !== "\n" && prev !== "	" && prev !== " ") {
    var msg = "Comments must be separated from other tokens by white space characters";
    errors.push(new YAMLSemanticError(comment, msg));
  }
}
function getLongKeyError(source, key) {
  var sk = String(key);
  var k = sk.substr(0, 8) + "..." + sk.substr(-8);
  return new YAMLSemanticError(source, 'The "'.concat(k, '" key is too long'));
}
function resolveComments(collection, comments) {
  var _iterator = _createForOfIteratorHelper(comments), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, afterKey = _step$value.afterKey, before = _step$value.before, comment = _step$value.comment;
      var item = collection.items[before];
      if (!item) {
        if (comment !== void 0) {
          if (collection.comment)
            collection.comment += "\n" + comment;
          else
            collection.comment = comment;
        }
      } else {
        if (afterKey && item.value)
          item = item.value;
        if (comment === void 0) {
          if (afterKey || !item.commentBefore)
            item.spaceBefore = true;
        } else {
          if (item.commentBefore)
            item.commentBefore += "\n" + comment;
          else
            item.commentBefore = comment;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function resolveString(doc, node) {
  var res = node.strValue;
  if (!res)
    return "";
  if (typeof res === "string")
    return res;
  res.errors.forEach(function(error) {
    if (!error.source)
      error.source = node;
    doc.errors.push(error);
  });
  return res.str;
}
function resolveTagHandle(doc, node) {
  var _node$tag = node.tag, handle = _node$tag.handle, suffix = _node$tag.suffix;
  var prefix = doc.tagPrefixes.find(function(p) {
    return p.handle === handle;
  });
  if (!prefix) {
    var dtp = doc.getDefaults().tagPrefixes;
    if (dtp)
      prefix = dtp.find(function(p) {
        return p.handle === handle;
      });
    if (!prefix)
      throw new YAMLSemanticError(node, "The ".concat(handle, " tag handle is non-default and was not declared."));
  }
  if (!suffix)
    throw new YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix."));
  if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
    if (suffix[0] === "^") {
      doc.warnings.push(new YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
      return suffix;
    }
    if (/[:/]/.test(suffix)) {
      var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
    }
  }
  return prefix.prefix + decodeURIComponent(suffix);
}
function resolveTagName(doc, node) {
  var tag = node.tag, type = node.type;
  var nonSpecific = false;
  if (tag) {
    var handle = tag.handle, suffix = tag.suffix, verbatim = tag.verbatim;
    if (verbatim) {
      if (verbatim !== "!" && verbatim !== "!!")
        return verbatim;
      var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
      doc.errors.push(new YAMLSemanticError(node, msg));
    } else if (handle === "!" && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }
  switch (type) {
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
    case Type.QUOTE_DOUBLE:
    case Type.QUOTE_SINGLE:
      return defaultTags.STR;
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    case Type.PLAIN:
      return nonSpecific ? defaultTags.STR : null;
    default:
      return null;
  }
}
function resolveByTagName(doc, node, tagName) {
  var tags2 = doc.schema.tags;
  var matchWithTest = [];
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var tag = _step.value;
      if (tag.tag === tagName) {
        if (tag.test)
          matchWithTest.push(tag);
        else {
          var res = tag.resolve(doc, node);
          return res instanceof Collection2 ? res : new Scalar(res);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var str = resolveString(doc, node);
  if (typeof str === "string" && matchWithTest.length > 0)
    return resolveScalar(str, matchWithTest, tags2.scalarFallback);
  return null;
}
function getFallbackTagName(_ref) {
  var type = _ref.type;
  switch (type) {
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    default:
      return defaultTags.STR;
  }
}
function resolveTag(doc, node, tagName) {
  try {
    var res = resolveByTagName(doc, node, tagName);
    if (res) {
      if (tagName && node.tag)
        res.tag = tagName;
      return res;
    }
  } catch (error) {
    if (!error.source)
      error.source = node;
    doc.errors.push(error);
    return null;
  }
  try {
    var fallback = getFallbackTagName(node);
    if (!fallback)
      throw new Error("The tag ".concat(tagName, " is unavailable"));
    var msg = "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback);
    doc.warnings.push(new YAMLWarning(node, msg));
    var _res = resolveByTagName(doc, node, fallback);
    _res.tag = tagName;
    return _res;
  } catch (error) {
    var refError = new YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}
function resolveNodeProps(errors, node) {
  var comments = {
    before: [],
    after: []
  };
  var hasAnchor = false;
  var hasTag = false;
  var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
  var _iterator = _createForOfIteratorHelper(props), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, start = _step$value.start, end = _step$value.end;
      switch (node.context.src[start]) {
        case Char.COMMENT: {
          if (!node.commentHasRequiredWhitespace(start)) {
            var msg = "Comments must be separated from other tokens by white space characters";
            errors.push(new YAMLSemanticError(node, msg));
          }
          var header = node.header, valueRange = node.valueRange;
          var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
        }
        case Char.ANCHOR:
          if (hasAnchor) {
            var _msg = "A node can have at most one anchor";
            errors.push(new YAMLSemanticError(node, _msg));
          }
          hasAnchor = true;
          break;
        case Char.TAG:
          if (hasTag) {
            var _msg2 = "A node can have at most one tag";
            errors.push(new YAMLSemanticError(node, _msg2));
          }
          hasTag = true;
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    comments,
    hasAnchor,
    hasTag
  };
}
function resolveNodeValue(doc, node) {
  var anchors = doc.anchors, errors = doc.errors, schema = doc.schema;
  if (node.type === Type.ALIAS) {
    var name = node.rawValue;
    var src = anchors.getNode(name);
    if (!src) {
      var msg = "Aliased anchor not found: ".concat(name);
      errors.push(new YAMLReferenceError(node, msg));
      return null;
    }
    var res = new Alias2(src);
    anchors._cstAliases.push(res);
    return res;
  }
  var tagName = resolveTagName(doc, node);
  if (tagName)
    return resolveTag(doc, node, tagName);
  if (node.type !== Type.PLAIN) {
    var _msg3 = "Failed to resolve ".concat(node.type, " node here");
    errors.push(new YAMLSyntaxError(node, _msg3));
    return null;
  }
  try {
    var str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
  } catch (error) {
    if (!error.source)
      error.source = node;
    errors.push(error);
    return null;
  }
}
function resolveNode(doc, node) {
  if (!node)
    return null;
  if (node.error)
    doc.errors.push(node.error);
  var _resolveNodeProps = resolveNodeProps(doc.errors, node), comments = _resolveNodeProps.comments, hasAnchor = _resolveNodeProps.hasAnchor, hasTag = _resolveNodeProps.hasTag;
  if (hasAnchor) {
    var anchors = doc.anchors;
    var name = node.anchor;
    var prev = anchors.getNode(name);
    if (prev)
      anchors.map[anchors.newName(name)] = prev;
    anchors.map[name] = node;
  }
  if (node.type === Type.ALIAS && (hasAnchor || hasTag)) {
    var msg = "An alias node must not specify any properties";
    doc.errors.push(new YAMLSemanticError(node, msg));
  }
  var res = resolveNodeValue(doc, node);
  if (res) {
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes)
      res.cstNode = node;
    if (doc.options.keepNodeTypes)
      res.type = node.type;
    var cb = comments.before.join("\n");
    if (cb) {
      res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
    }
    var ca = comments.after.join("\n");
    if (ca)
      res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
  }
  return node.resolved = res;
}
function resolveMap(doc, cst) {
  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst), comments = _ref.comments, items = _ref.items;
  var map2 = new YAMLMap();
  map2.items = items;
  resolveComments(map2, comments);
  var hasCollectionKey = false;
  for (var i = 0; i < items.length; ++i) {
    var iKey = items[i].key;
    if (iKey instanceof Collection2)
      hasCollectionKey = true;
    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
      items[i] = new Merge(items[i]);
      var sources = items[i].value.items;
      var error = null;
      sources.some(function(node) {
        if (node instanceof Alias2) {
          var type = node.source.type;
          if (type === Type.MAP || type === Type.FLOW_MAP)
            return false;
          return error = "Merge nodes aliases can only point to maps";
        }
        return error = "Merge nodes can only have Alias nodes as values";
      });
      if (error)
        doc.errors.push(new YAMLSemanticError(cst, error));
    } else {
      for (var j = i + 1; j < items.length; ++j) {
        var jKey = items[j].key;
        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
          var _msg = 'Map keys must be unique; "'.concat(iKey, '" is repeated');
          doc.errors.push(new YAMLSemanticError(cst, _msg));
          break;
        }
      }
    }
  }
  if (hasCollectionKey && !doc.options.mapAsMap) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = map2;
  return map2;
}
function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item))
    return;
  var comment = item.getPropValue(0, Char.COMMENT, true);
  var found = false;
  var cb = pair.value.commentBefore;
  if (cb && cb.startsWith(comment)) {
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    var cc = pair.value.comment;
    if (!item.node && cc && cc.startsWith(comment)) {
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }
  if (found)
    pair.comment = comment;
}
function resolveBlockMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key = void 0;
  var keyStart = null;
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;
      case Type.MAP_KEY:
        if (key !== void 0)
          items.push(new Pair(key));
        if (item.error)
          doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;
      case Type.MAP_VALUE:
        {
          if (key === void 0)
            key = null;
          if (item.error)
            doc.errors.push(item.error);
          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {
            var msg = "Nested mappings are not allowed in compact mappings";
            doc.errors.push(new YAMLSemanticError(item.node, msg));
          }
          var valueNode = item.node;
          if (!valueNode && item.props.length > 0) {
            valueNode = new PlainValue(Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            var pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };
            if (typeof item.range.origStart === "number") {
              var origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }
          var pair = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);
          if (key && typeof keyStart === "number") {
            if (item.range.start > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key));
          }
          key = void 0;
          keyStart = null;
        }
        break;
      default:
        if (key !== void 0)
          items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error)
          doc.errors.push(item.error);
        next:
          for (var j = i + 1; ; ++j) {
            var nextItem = cst.items[j];
            switch (nextItem && nextItem.type) {
              case Type.BLANK_LINE:
              case Type.COMMENT:
                continue next;
              case Type.MAP_VALUE:
                break next;
              default: {
                var _msg2 = "Implicit map keys need to be followed by map values";
                doc.errors.push(new YAMLSemanticError(item, _msg2));
                break next;
              }
            }
          }
        if (item.valueRangeContainsNewline) {
          var _msg3 = "Implicit map keys need to be on a single line";
          doc.errors.push(new YAMLSemanticError(item, _msg3));
        }
    }
  }
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
function resolveFlowMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key = void 0;
  var explicitKey = false;
  var next = "{";
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    if (typeof item.char === "string") {
      var char = item.char, offset = item.offset;
      if (char === "?" && key === void 0 && !explicitKey) {
        explicitKey = true;
        next = ":";
        continue;
      }
      if (char === ":") {
        if (key === void 0)
          key = null;
        if (next === ":") {
          next = ",";
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === void 0 && char !== ",")
            key = null;
          explicitKey = false;
        }
        if (key !== void 0) {
          items.push(new Pair(key));
          key = void 0;
          if (char === ",") {
            next = ":";
            continue;
          }
        }
      }
      if (char === "}") {
        if (i === cst.items.length - 1)
          continue;
      } else if (char === next) {
        next = ":";
        continue;
      }
      var msg = "Flow map contains an unexpected ".concat(char);
      var err = new YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === void 0) {
      if (next === ",")
        doc.errors.push(new YAMLSemanticError(item, "Separator , missing in flow map"));
      key = resolveNode(doc, item);
    } else {
      if (next !== ",")
        doc.errors.push(new YAMLSemanticError(item, "Indicator : missing in flow map entry"));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = void 0;
      explicitKey = false;
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
function resolveSeq(doc, cst) {
  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst), comments = _ref.comments, items = _ref.items;
  var seq2 = new YAMLSeq();
  seq2.items = items;
  resolveComments(seq2, comments);
  if (!doc.options.mapAsMap && items.some(function(it) {
    return it instanceof Pair && it.key instanceof Collection2;
  })) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = seq2;
  return seq2;
}
function resolveBlockSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;
      case Type.SEQ_ITEM:
        if (item.error)
          doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));
        if (item.hasProps) {
          var msg = "Sequence items cannot have tags or anchors before the - indicator";
          doc.errors.push(new YAMLSemanticError(item, msg));
        }
        break;
      default:
        if (item.error)
          doc.errors.push(item.error);
        doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
    }
  }
  return {
    comments,
    items
  };
}
function resolveFlowSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  var explicitKey = false;
  var key = void 0;
  var keyStart = null;
  var next = "[";
  var prevItem = null;
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    if (typeof item.char === "string") {
      var char = item.char, offset = item.offset;
      if (char !== ":" && (explicitKey || key !== void 0)) {
        if (explicitKey && key === void 0)
          key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = void 0;
        keyStart = null;
      }
      if (char === next) {
        next = null;
      } else if (!next && char === "?") {
        explicitKey = true;
      } else if (next !== "[" && char === ":" && key === void 0) {
        if (next === ",") {
          key = items.pop();
          if (key instanceof Pair) {
            var msg = "Chaining flow sequence pairs is invalid";
            var err = new YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
          if (!explicitKey && typeof keyStart === "number") {
            var keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key));
            var src = prevItem.context.src;
            for (var _i = keyStart; _i < keyEnd; ++_i) {
              if (src[_i] === "\n") {
                var _msg = "Implicit keys of flow sequence pairs need to be on a single line";
                doc.errors.push(new YAMLSemanticError(prevItem, _msg));
                break;
              }
            }
          }
        } else {
          key = null;
        }
        keyStart = null;
        explicitKey = false;
        next = null;
      } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
        var _msg2 = "Flow sequence contains an unexpected ".concat(char);
        var _err = new YAMLSyntaxError(cst, _msg2);
        _err.offset = offset;
        doc.errors.push(_err);
      }
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        var _msg3 = "Expected a ".concat(next, " in flow sequence");
        doc.errors.push(new YAMLSemanticError(item, _msg3));
      }
      var value = resolveNode(doc, item);
      if (key === void 0) {
        items.push(value);
        prevItem = item;
      } else {
        items.push(new Pair(key, value));
        key = void 0;
      }
      keyStart = item.range.start;
      next = ",";
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
var Node2, Scalar, isEmptyPath, Collection2, YAMLSeq, stringifyKey, Pair, getAliasCount, Alias2, YAMLMap, MERGE_KEY, Merge, binaryOptions, boolOptions, intOptions, nullOptions, strOptions, FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED, consumeMoreIndentedLines, getFoldOptions, containsDocumentMarker, isCollectionItem, valueHasPairComment;
var init_resolveSeq_492ab440 = __esm({
  "node_modules/yaml/browser/dist/resolveSeq-492ab440.js"() {
    init_PlainValue_b8036b75();
    Node2 = function Node3() {
      _classCallCheck(this, Node3);
    };
    Scalar = function(_Node) {
      _inherits(Scalar2, _Node);
      var _super = _createSuper(Scalar2);
      function Scalar2(value) {
        var _this;
        _classCallCheck(this, Scalar2);
        _this = _super.call(this);
        _this.value = value;
        return _this;
      }
      _createClass(Scalar2, [{
        key: "toJSON",
        value: function toJSON$1(arg, ctx) {
          return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
        }
      }, {
        key: "toString",
        value: function toString() {
          return String(this.value);
        }
      }]);
      return Scalar2;
    }(Node2);
    isEmptyPath = function isEmptyPath2(path) {
      return path == null || _typeof(path) === "object" && path[Symbol.iterator]().next().done;
    };
    Collection2 = function(_Node) {
      _inherits(Collection3, _Node);
      var _super = _createSuper(Collection3);
      function Collection3(schema) {
        var _this;
        _classCallCheck(this, Collection3);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "items", []);
        _this.schema = schema;
        return _this;
      }
      _createClass(Collection3, [{
        key: "addIn",
        value: function addIn(path, value) {
          if (isEmptyPath(path))
            this.add(value);
          else {
            var _path = _toArray(path), key = _path[0], rest = _path.slice(1);
            var node = this.get(key, true);
            if (node instanceof Collection3)
              node.addIn(rest, value);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value));
            else
              throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        }
      }, {
        key: "deleteIn",
        value: function deleteIn(_ref) {
          var _ref2 = _toArray(_ref), key = _ref2[0], rest = _ref2.slice(1);
          if (rest.length === 0)
            return this.delete(key);
          var node = this.get(key, true);
          if (node instanceof Collection3)
            return node.deleteIn(rest);
          else
            throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
        }
      }, {
        key: "getIn",
        value: function getIn(_ref3, keepScalar) {
          var _ref4 = _toArray(_ref3), key = _ref4[0], rest = _ref4.slice(1);
          var node = this.get(key, true);
          if (rest.length === 0)
            return !keepScalar && node instanceof Scalar ? node.value : node;
          else
            return node instanceof Collection3 ? node.getIn(rest, keepScalar) : void 0;
        }
      }, {
        key: "hasAllNullValues",
        value: function hasAllNullValues() {
          return this.items.every(function(node) {
            if (!node || node.type !== "PAIR")
              return false;
            var n = node.value;
            return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
          });
        }
      }, {
        key: "hasIn",
        value: function hasIn(_ref5) {
          var _ref6 = _toArray(_ref5), key = _ref6[0], rest = _ref6.slice(1);
          if (rest.length === 0)
            return this.has(key);
          var node = this.get(key, true);
          return node instanceof Collection3 ? node.hasIn(rest) : false;
        }
      }, {
        key: "setIn",
        value: function setIn(_ref7, value) {
          var _ref8 = _toArray(_ref7), key = _ref8[0], rest = _ref8.slice(1);
          if (rest.length === 0) {
            this.set(key, value);
          } else {
            var node = this.get(key, true);
            if (node instanceof Collection3)
              node.setIn(rest, value);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value));
            else
              throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        }
        // overridden in implementations
        /* istanbul ignore next */
      }, {
        key: "toJSON",
        value: function toJSON2() {
          return null;
        }
      }, {
        key: "toString",
        value: function toString(ctx, _ref9, onComment, onChompKeep) {
          var _this2 = this;
          var blockItem = _ref9.blockItem, flowChars = _ref9.flowChars, isMap = _ref9.isMap, itemIndent = _ref9.itemIndent;
          var _ctx = ctx, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
          var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;
          if (inFlow)
            itemIndent += indentStep;
          var allNullValues = isMap && this.hasAllNullValues();
          ctx = Object.assign({}, ctx, {
            allNullValues,
            indent: itemIndent,
            inFlow,
            type: null
          });
          var chompKeep = false;
          var hasItemWithNewLine = false;
          var nodes = this.items.reduce(function(nodes2, item, i) {
            var comment;
            if (item) {
              if (!chompKeep && item.spaceBefore)
                nodes2.push({
                  type: "comment",
                  str: ""
                });
              if (item.commentBefore)
                item.commentBefore.match(/^.*$/gm).forEach(function(line) {
                  nodes2.push({
                    type: "comment",
                    str: "#".concat(line)
                  });
                });
              if (item.comment)
                comment = item.comment;
              if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
                hasItemWithNewLine = true;
            }
            chompKeep = false;
            var str2 = stringify16(item, ctx, function() {
              return comment = null;
            }, function() {
              return chompKeep = true;
            });
            if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
              hasItemWithNewLine = true;
            if (inFlow && i < _this2.items.length - 1)
              str2 += ",";
            str2 = addComment(str2, itemIndent, comment);
            if (chompKeep && (comment || inFlow))
              chompKeep = false;
            nodes2.push({
              type: "item",
              str: str2
            });
            return nodes2;
          }, []);
          var str;
          if (nodes.length === 0) {
            str = flowChars.start + flowChars.end;
          } else if (inFlow) {
            var start = flowChars.start, end = flowChars.end;
            var strings = nodes.map(function(n) {
              return n.str;
            });
            if (hasItemWithNewLine || strings.reduce(function(sum, str2) {
              return sum + str2.length + 2;
            }, 2) > Collection3.maxFlowStringSingleLineLength) {
              str = start;
              var _iterator = _createForOfIteratorHelper(strings), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var s = _step.value;
                  str += s ? "\n".concat(indentStep).concat(indent).concat(s) : "\n";
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              str += "\n".concat(indent).concat(end);
            } else {
              str = "".concat(start, " ").concat(strings.join(" "), " ").concat(end);
            }
          } else {
            var _strings = nodes.map(blockItem);
            str = _strings.shift();
            var _iterator2 = _createForOfIteratorHelper(_strings), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _s = _step2.value;
                str += _s ? "\n".concat(indent).concat(_s) : "\n";
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          if (this.comment) {
            str += "\n" + this.comment.replace(/^/gm, "".concat(indent, "#"));
            if (onComment)
              onComment();
          } else if (chompKeep && onChompKeep)
            onChompKeep();
          return str;
        }
      }]);
      return Collection3;
    }(Node2);
    _defineProperty(Collection2, "maxFlowStringSingleLineLength", 60);
    YAMLSeq = function(_Collection) {
      _inherits(YAMLSeq2, _Collection);
      var _super = _createSuper(YAMLSeq2);
      function YAMLSeq2() {
        _classCallCheck(this, YAMLSeq2);
        return _super.apply(this, arguments);
      }
      _createClass(YAMLSeq2, [{
        key: "add",
        value: function add(value) {
          this.items.push(value);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            return false;
          var del = this.items.splice(idx, 1);
          return del.length > 0;
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            return void 0;
          var it = this.items[idx];
          return !keepScalar && it instanceof Scalar ? it.value : it;
        }
      }, {
        key: "has",
        value: function has(key) {
          var idx = asItemIndex(key);
          return typeof idx === "number" && idx < this.items.length;
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            throw new Error("Expected a valid index, not ".concat(key, "."));
          this.items[idx] = value;
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(_, ctx) {
          var seq2 = [];
          if (ctx && ctx.onCreate)
            ctx.onCreate(seq2);
          var i = 0;
          var _iterator = _createForOfIteratorHelper(this.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var item = _step.value;
              seq2.push(toJSON(item, String(i++), ctx));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return seq2;
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          return _get(_getPrototypeOf(YAMLSeq2.prototype), "toString", this).call(this, ctx, {
            blockItem: function blockItem(n) {
              return n.type === "comment" ? n.str : "- ".concat(n.str);
            },
            flowChars: {
              start: "[",
              end: "]"
            },
            isMap: false,
            itemIndent: (ctx.indent || "") + "  "
          }, onComment, onChompKeep);
        }
      }]);
      return YAMLSeq2;
    }(Collection2);
    stringifyKey = function stringifyKey2(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (_typeof(jsKey) !== "object")
        return String(jsKey);
      if (key instanceof Node2 && ctx && ctx.doc)
        return key.toString({
          anchors: /* @__PURE__ */ Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    Pair = function(_Node) {
      _inherits(Pair2, _Node);
      var _super = _createSuper(Pair2);
      function Pair2(key) {
        var _this;
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Pair2);
        _this = _super.call(this);
        _this.key = key;
        _this.value = value;
        _this.type = Pair2.Type.PAIR;
        return _this;
      }
      _createClass(Pair2, [{
        key: "commentBefore",
        get: function get() {
          return this.key instanceof Node2 ? this.key.commentBefore : void 0;
        },
        set: function set2(cb) {
          if (this.key == null)
            this.key = new Scalar(null);
          if (this.key instanceof Node2)
            this.key.commentBefore = cb;
          else {
            var msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
            throw new Error(msg);
          }
        }
      }, {
        key: "addToJSMap",
        value: function addToJSMap(ctx, map2) {
          var key = toJSON(this.key, "", ctx);
          if (map2 instanceof Map) {
            var value = toJSON(this.value, key, ctx);
            map2.set(key, value);
          } else if (map2 instanceof Set) {
            map2.add(key);
          } else {
            var stringKey = stringifyKey(this.key, key, ctx);
            var _value = toJSON(this.value, stringKey, ctx);
            if (stringKey in map2)
              Object.defineProperty(map2, stringKey, {
                value: _value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            else
              map2[stringKey] = _value;
          }
          return map2;
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx) {
          var pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
          return this.addToJSMap(ctx, pair);
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx || !ctx.doc)
            return JSON.stringify(this);
          var _ctx$doc$options = ctx.doc.options, indentSize = _ctx$doc$options.indent, indentSeq = _ctx$doc$options.indentSeq, simpleKeys = _ctx$doc$options.simpleKeys;
          var key = this.key, value = this.value;
          var keyComment = key instanceof Node2 && key.comment;
          if (simpleKeys) {
            if (keyComment) {
              throw new Error("With simple keys, key nodes cannot have comments");
            }
            if (key instanceof Collection2) {
              var msg = "With simple keys, collection cannot be used as a key value";
              throw new Error(msg);
            }
          }
          var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node2 ? key instanceof Collection2 || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL : _typeof(key) === "object"));
          var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
          ctx = Object.assign({}, ctx, {
            implicitKey: !explicitKey,
            indent: indent + indentStep
          });
          var chompKeep = false;
          var str = stringify16(key, ctx, function() {
            return keyComment = null;
          }, function() {
            return chompKeep = true;
          });
          str = addComment(str, ctx.indent, keyComment);
          if (!explicitKey && str.length > 1024) {
            if (simpleKeys)
              throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
            explicitKey = true;
          }
          if (ctx.allNullValues && !simpleKeys) {
            if (this.comment) {
              str = addComment(str, ctx.indent, this.comment);
              if (onComment)
                onComment();
            } else if (chompKeep && !keyComment && onChompKeep)
              onChompKeep();
            return ctx.inFlow && !explicitKey ? str : "? ".concat(str);
          }
          str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment)
              onComment();
          }
          var vcb = "";
          var valueComment = null;
          if (value instanceof Node2) {
            if (value.spaceBefore)
              vcb = "\n";
            if (value.commentBefore) {
              var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
              vcb += "\n".concat(cs);
            }
            valueComment = value.comment;
          } else if (value && _typeof(value) === "object") {
            value = doc.schema.createNode(value, true);
          }
          ctx.implicitKey = false;
          if (!explicitKey && !this.comment && value instanceof Scalar)
            ctx.indentAtStart = str.length + 1;
          chompKeep = false;
          if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
            ctx.indent = ctx.indent.substr(2);
          }
          var valueStr = stringify16(value, ctx, function() {
            return valueComment = null;
          }, function() {
            return chompKeep = true;
          });
          var ws = " ";
          if (vcb || this.comment) {
            ws = "".concat(vcb, "\n").concat(ctx.indent);
          } else if (!explicitKey && value instanceof Collection2) {
            var flow = valueStr[0] === "[" || valueStr[0] === "{";
            if (!flow || valueStr.includes("\n"))
              ws = "\n".concat(ctx.indent);
          } else if (valueStr[0] === "\n")
            ws = "";
          if (chompKeep && !valueComment && onChompKeep)
            onChompKeep();
          return addComment(str + ws + valueStr, ctx.indent, valueComment);
        }
      }]);
      return Pair2;
    }(Node2);
    _defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    getAliasCount = function getAliasCount2(node, anchors) {
      if (node instanceof Alias2) {
        var anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection2) {
        var count = 0;
        var _iterator = _createForOfIteratorHelper(node.items), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var item = _step.value;
            var c = getAliasCount2(item, anchors);
            if (c > count)
              count = c;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return count;
      } else if (node instanceof Pair) {
        var kc = getAliasCount2(node.key, anchors);
        var vc = getAliasCount2(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    Alias2 = function(_Node) {
      _inherits(Alias3, _Node);
      var _super = _createSuper(Alias3);
      function Alias3(source) {
        var _this;
        _classCallCheck(this, Alias3);
        _this = _super.call(this);
        _this.source = source;
        _this.type = Type.ALIAS;
        return _this;
      }
      _createClass(Alias3, [{
        key: "tag",
        set: function set2(t) {
          throw new Error("Alias nodes cannot have tags");
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(arg, ctx) {
          if (!ctx)
            return toJSON(this.source, arg, ctx);
          var anchors = ctx.anchors, maxAliasCount = ctx.maxAliasCount;
          var anchor = anchors.get(this.source);
          if (!anchor || anchor.res === void 0) {
            var msg = "This should not happen: Alias anchor was not resolved?";
            if (this.cstNode)
              throw new YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
          if (maxAliasCount >= 0) {
            anchor.count += 1;
            if (anchor.aliasCount === 0)
              anchor.aliasCount = getAliasCount(this.source, anchors);
            if (anchor.count * anchor.aliasCount > maxAliasCount) {
              var _msg = "Excessive alias count indicates a resource exhaustion attack";
              if (this.cstNode)
                throw new YAMLReferenceError(this.cstNode, _msg);
              else
                throw new ReferenceError(_msg);
            }
          }
          return anchor.res;
        }
        // Only called when stringifying an alias mapping key while constructing
        // Object output.
      }, {
        key: "toString",
        value: function toString(ctx) {
          return Alias3.stringify(this, ctx);
        }
      }], [{
        key: "stringify",
        value: function stringify16(_ref, _ref2) {
          var range = _ref.range, source = _ref.source;
          var anchors = _ref2.anchors, doc = _ref2.doc, implicitKey = _ref2.implicitKey, inStringifyKey = _ref2.inStringifyKey;
          var anchor = Object.keys(anchors).find(function(a) {
            return anchors[a] === source;
          });
          if (!anchor && inStringifyKey)
            anchor = doc.anchors.getName(source) || doc.anchors.newName();
          if (anchor)
            return "*".concat(anchor).concat(implicitKey ? " " : "");
          var msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
          throw new Error("".concat(msg, " [").concat(range, "]"));
        }
      }]);
      return Alias3;
    }(Node2);
    _defineProperty(Alias2, "default", true);
    YAMLMap = function(_Collection) {
      _inherits(YAMLMap2, _Collection);
      var _super = _createSuper(YAMLMap2);
      function YAMLMap2() {
        _classCallCheck(this, YAMLMap2);
        return _super.apply(this, arguments);
      }
      _createClass(YAMLMap2, [{
        key: "add",
        value: function add(pair, overwrite) {
          if (!pair)
            pair = new Pair(pair);
          else if (!(pair instanceof Pair))
            pair = new Pair(pair.key || pair, pair.value);
          var prev = findPair(this.items, pair.key);
          var sortEntries = this.schema && this.schema.sortMapEntries;
          if (prev) {
            if (overwrite)
              prev.value = pair.value;
            else
              throw new Error("Key ".concat(pair.key, " already set"));
          } else if (sortEntries) {
            var i = this.items.findIndex(function(item) {
              return sortEntries(pair, item) < 0;
            });
            if (i === -1)
              this.items.push(pair);
            else
              this.items.splice(i, 0, pair);
          } else {
            this.items.push(pair);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var it = findPair(this.items, key);
          if (!it)
            return false;
          var del = this.items.splice(this.items.indexOf(it), 1);
          return del.length > 0;
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          var it = findPair(this.items, key);
          var node = it && it.value;
          return !keepScalar && node instanceof Scalar ? node.value : node;
        }
      }, {
        key: "has",
        value: function has(key) {
          return !!findPair(this.items, key);
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          this.add(new Pair(key, value), true);
        }
        /**
         * @param {*} arg ignored
         * @param {*} ctx Conversion context, originally set in Document#toJSON()
         * @param {Class} Type If set, forces the returned collection type
         * @returns {*} Instance of Type, Map, or Object
         */
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx, Type2) {
          var map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
          if (ctx && ctx.onCreate)
            ctx.onCreate(map2);
          var _iterator2 = _createForOfIteratorHelper(this.items), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var item = _step2.value;
              item.addToJSMap(ctx, map2);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return map2;
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          var _iterator3 = _createForOfIteratorHelper(this.items), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var item = _step3.value;
              if (!(item instanceof Pair))
                throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return _get(_getPrototypeOf(YAMLMap2.prototype), "toString", this).call(this, ctx, {
            blockItem: function blockItem(n) {
              return n.str;
            },
            flowChars: {
              start: "{",
              end: "}"
            },
            isMap: true,
            itemIndent: ctx.indent || ""
          }, onComment, onChompKeep);
        }
      }]);
      return YAMLMap2;
    }(Collection2);
    MERGE_KEY = "<<";
    Merge = function(_Pair) {
      _inherits(Merge2, _Pair);
      var _super = _createSuper(Merge2);
      function Merge2(pair) {
        var _this;
        _classCallCheck(this, Merge2);
        if (pair instanceof Pair) {
          var seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          _this = _super.call(this, pair.key, seq2);
          _this.range = pair.range;
        } else {
          _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());
        }
        _this.type = Pair.Type.MERGE_PAIR;
        return _possibleConstructorReturn(_this);
      }
      _createClass(Merge2, [{
        key: "addToJSMap",
        value: function addToJSMap(ctx, map2) {
          var _iterator = _createForOfIteratorHelper(this.value.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var source = _step.value.source;
              if (!(source instanceof YAMLMap))
                throw new Error("Merge sources must be maps");
              var srcMap = source.toJSON(null, ctx, Map);
              var _iterator2 = _createForOfIteratorHelper(srcMap), _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], value = _step2$value[1];
                  if (map2 instanceof Map) {
                    if (!map2.has(key))
                      map2.set(key, value);
                  } else if (map2 instanceof Set) {
                    map2.add(key);
                  } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
                    Object.defineProperty(map2, key, {
                      value,
                      writable: true,
                      enumerable: true,
                      configurable: true
                    });
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return map2;
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment) {
          var seq2 = this.value;
          if (seq2.items.length > 1)
            return _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
          this.value = seq2.items[0];
          var str = _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
          this.value = seq2;
          return str;
        }
      }]);
      return Merge2;
    }(Pair);
    binaryOptions = {
      defaultType: Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    intOptions = {
      asBigInt: false
    };
    nullOptions = {
      nullStr: "null"
    };
    strOptions = {
      defaultType: Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
    consumeMoreIndentedLines = function consumeMoreIndentedLines2(text, i) {
      var ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    getFoldOptions = function getFoldOptions2(_ref) {
      var indentAtStart = _ref.indentAtStart;
      return indentAtStart ? Object.assign({
        indentAtStart
      }, strOptions.fold) : strOptions.fold;
    };
    containsDocumentMarker = function containsDocumentMarker2(str) {
      return /^(%|---|\.\.\.)/m.test(str);
    };
    isCollectionItem = function isCollectionItem2(node) {
      if (!node)
        return false;
      var type = node.type;
      return type === Type.MAP_KEY || type === Type.MAP_VALUE || type === Type.SEQ_ITEM;
    };
    valueHasPairComment = function valueHasPairComment2(_ref2) {
      var _ref2$context = _ref2.context, lineStart = _ref2$context.lineStart, node = _ref2$context.node, src = _ref2$context.src, props = _ref2.props;
      if (props.length === 0)
        return false;
      var start = props[0].start;
      if (node && start > node.valueRange.start)
        return false;
      if (src[start] !== Char.COMMENT)
        return false;
      for (var i = lineStart; i < start; ++i) {
        if (src[i] === "\n")
          return false;
      }
      return true;
    };
  }
});

// node_modules/yaml/browser/dist/warnings-df54cb69.js
function parsePairs(doc, cst) {
  var seq2 = resolveSeq(doc, cst);
  for (var i = 0; i < seq2.items.length; ++i) {
    var item = seq2.items[i];
    if (item instanceof Pair)
      continue;
    else if (item instanceof YAMLMap) {
      if (item.items.length > 1) {
        var msg = "Each pair must have its own sequence indicator";
        throw new YAMLSemanticError(cst, msg);
      }
      var pair = item.items[0] || new Pair();
      if (item.commentBefore)
        pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
      if (item.comment)
        pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
      item = pair;
    }
    seq2.items[i] = item instanceof Pair ? item : new Pair(item);
  }
  return seq2;
}
function createPairs(schema, iterable, ctx) {
  var pairs2 = new YAMLSeq(schema);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it = _step.value;
      var key = void 0, value = void 0;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError("Expected [key, value] tuple: ".concat(it));
      } else if (it && it instanceof Object) {
        var keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError("Expected { key: value } tuple: ".concat(it));
      } else {
        key = it;
      }
      var pair = schema.createPair(key, value, ctx);
      pairs2.items.push(pair);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return pairs2;
}
function parseOMap(doc, cst) {
  var pairs2 = parsePairs(doc, cst);
  var seenKeys = [];
  var _iterator2 = _createForOfIteratorHelper(pairs2.items), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var key = _step2.value.key;
      if (key instanceof Scalar) {
        if (seenKeys.includes(key.value)) {
          var msg = "Ordered maps must not include duplicate keys";
          throw new YAMLSemanticError(cst, msg);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return Object.assign(new YAMLOMap(), pairs2);
}
function createOMap(schema, iterable, ctx) {
  var pairs2 = createPairs(schema, iterable, ctx);
  var omap2 = new YAMLOMap();
  omap2.items = pairs2.items;
  return omap2;
}
function parseSet(doc, cst) {
  var map2 = resolveMap(doc, cst);
  if (!map2.hasAllNullValues())
    throw new YAMLSemanticError(cst, "Set items must all have null values");
  return Object.assign(new YAMLSet(), map2);
}
function createSet(schema, iterable, ctx) {
  var set2 = new YAMLSet();
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var value = _step.value;
      set2.items.push(schema.createPair(value, null, ctx));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return set2;
}
function shouldWarn(deprecation) {
  var env = typeof process !== "undefined" && process.env || {};
  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
      return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }
  if (typeof YAML_SILENCE_WARNINGS !== "undefined")
    return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}
function warn(warning, type) {
  if (shouldWarn(false)) {
    var emit = typeof process !== "undefined" && process.emitWarning;
    if (emit)
      emit(warning, type);
    else {
      console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
    }
  }
}
function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    var msg = "The option '".concat(name, "' will be removed in a future release");
    msg += alternative ? ", use '".concat(alternative, "' instead.") : ".";
    warn(msg, "DeprecationWarning");
  }
}
var binary, pairs, YAMLOMap, omap, YAMLSet, set, parseSexagesimal, stringifySexagesimal, intTime, floatTime, timestamp, warned;
var init_warnings_df54cb69 = __esm({
  "node_modules/yaml/browser/dist/warnings-df54cb69.js"() {
    init_PlainValue_b8036b75();
    init_resolveSeq_492ab440();
    binary = {
      identify: function identify(value) {
        return value instanceof Uint8Array;
      },
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve: function resolve(doc, node) {
        var src = resolveString(doc, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          var str = atob(src.replace(/[\n\r]/g, ""));
          var buffer = new Uint8Array(str.length);
          for (var i = 0; i < str.length; ++i) {
            buffer[i] = str.charCodeAt(i);
          }
          return buffer;
        } else {
          var msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: binaryOptions,
      stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
        var comment = _ref.comment, type = _ref.type, value = _ref.value;
        var src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          var s = "";
          for (var i = 0; i < value.length; ++i) {
            s += String.fromCharCode(value[i]);
          }
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = binaryOptions.defaultType;
        if (type === Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          var lineWidth = binaryOptions.lineWidth;
          var n = Math.ceil(src.length / lineWidth);
          var lines = new Array(n);
          for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {
            lines[_i] = src.substr(o, lineWidth);
          }
          value = lines.join(type === Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({
          comment,
          type,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    YAMLOMap = function(_YAMLSeq) {
      _inherits(YAMLOMap2, _YAMLSeq);
      var _super = _createSuper(YAMLOMap2);
      function YAMLOMap2() {
        var _this;
        _classCallCheck(this, YAMLOMap2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "add", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "delete", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "get", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "has", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "set", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));
        _this.tag = YAMLOMap2.tag;
        return _this;
      }
      _createClass(YAMLOMap2, [{
        key: "toJSON",
        value: function toJSON$1(_, ctx) {
          var map2 = /* @__PURE__ */ new Map();
          if (ctx && ctx.onCreate)
            ctx.onCreate(map2);
          var _iterator = _createForOfIteratorHelper(this.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var pair = _step.value;
              var key = void 0, value = void 0;
              if (pair instanceof Pair) {
                key = toJSON(pair.key, "", ctx);
                value = toJSON(pair.value, key, ctx);
              } else {
                key = toJSON(pair, "", ctx);
              }
              if (map2.has(key))
                throw new Error("Ordered maps must not include duplicate keys");
              map2.set(key, value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return map2;
        }
      }]);
      return YAMLOMap2;
    }(YAMLSeq);
    _defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    omap = {
      identify: function identify2(value) {
        return value instanceof Map;
      },
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    YAMLSet = function(_YAMLMap) {
      _inherits(YAMLSet2, _YAMLMap);
      var _super = _createSuper(YAMLSet2);
      function YAMLSet2() {
        var _this;
        _classCallCheck(this, YAMLSet2);
        _this = _super.call(this);
        _this.tag = YAMLSet2.tag;
        return _this;
      }
      _createClass(YAMLSet2, [{
        key: "add",
        value: function add(key) {
          var pair = key instanceof Pair ? key : new Pair(key);
          var prev = findPair(this.items, pair.key);
          if (!prev)
            this.items.push(pair);
        }
      }, {
        key: "get",
        value: function get(key, keepPair) {
          var pair = findPair(this.items, key);
          return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          if (typeof value !== "boolean")
            throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof(value)));
          var prev = findPair(this.items, key);
          if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
          } else if (!prev && value) {
            this.items.push(new Pair(key));
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx) {
          return _get(_getPrototypeOf(YAMLSet2.prototype), "toJSON", this).call(this, _, ctx, Set);
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          if (this.hasAllNullValues())
            return _get(_getPrototypeOf(YAMLSet2.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);
          else
            throw new Error("Set items must all have null values");
        }
      }]);
      return YAMLSet2;
    }(YAMLMap);
    _defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    set = {
      identify: function identify3(value) {
        return value instanceof Set;
      },
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    parseSexagesimal = function parseSexagesimal2(sign, parts) {
      var n = parts.split(":").reduce(function(n2, p) {
        return n2 * 60 + Number(p);
      }, 0);
      return sign === "-" ? -n : n;
    };
    stringifySexagesimal = function stringifySexagesimal2(_ref) {
      var value = _ref.value;
      if (isNaN(value) || !isFinite(value))
        return stringifyNumber(value);
      var sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      var parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map(function(n) {
        return n < 10 ? "0" + String(n) : String(n);
      }).join(":").replace(/000000\d*$/, "");
    };
    intTime = {
      identify: function identify4(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: function resolve2(str, sign, parts) {
        return parseSexagesimal(sign, parts.replace(/_/g, ""));
      },
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: function identify5(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: function resolve3(str, sign, parts) {
        return parseSexagesimal(sign, parts.replace(/_/g, ""));
      },
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: function identify6(value) {
        return value instanceof Date;
      },
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: function resolve4(str, year, month, day, hour, minute, second, millisec, tz) {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          var d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: function stringify2(_ref2) {
        var value = _ref2.value;
        return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
      }
    };
    warned = {};
  }
});

// node_modules/yaml/browser/dist/Schema-e94716c8.js
function createMap(schema, obj, ctx) {
  var map2 = new YAMLMap(schema);
  if (obj instanceof Map) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
        map2.items.push(schema.createPair(key, value, ctx));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (obj && _typeof(obj) === "object") {
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];
      map2.items.push(schema.createPair(_key, obj[_key], ctx));
    }
  }
  if (typeof schema.sortMapEntries === "function") {
    map2.items.sort(schema.sortMapEntries);
  }
  return map2;
}
function createSeq(schema, obj, ctx) {
  var seq2 = new YAMLSeq(schema);
  if (obj && obj[Symbol.iterator]) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var it = _step.value;
        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);
        seq2.items.push(v);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return seq2;
}
function intStringify$1(node, radix, prefix) {
  var value = node.value;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
function intResolve2(sign, src, radix) {
  var str = src.replace(/_/g, "");
  if (intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = "0b".concat(str);
        break;
      case 8:
        str = "0o".concat(str);
        break;
      case 16:
        str = "0x".concat(str);
        break;
    }
    var _n = BigInt(str);
    return sign === "-" ? BigInt(-1) * _n : _n;
  }
  var n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
  var value = node.value;
  if (intIdentify3(value)) {
    var str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
function findTagObject(value, tagName, tags2) {
  if (tagName) {
    var match = tags2.filter(function(t) {
      return t.tag === tagName;
    });
    var tagObj = match.find(function(t) {
      return !t.format;
    }) || match[0];
    if (!tagObj)
      throw new Error("Tag ".concat(tagName, " not found"));
    return tagObj;
  }
  return tags2.find(function(t) {
    return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;
  });
}
function createNode4(value, tagName, ctx) {
  if (value instanceof Node2)
    return value;
  var defaultPrefix = ctx.defaultPrefix, onTagObj = ctx.onTagObj, prevObjects = ctx.prevObjects, schema = ctx.schema, wrapScalars = ctx.wrapScalars;
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultPrefix + tagName.slice(2);
  var tagObj = findTagObject(value, tagName, schema.tags);
  if (!tagObj) {
    if (typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || _typeof(value) !== "object")
      return wrapScalars ? new Scalar(value) : value;
    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  var obj = {
    value: void 0,
    node: void 0
  };
  if (value && _typeof(value) === "object" && prevObjects) {
    var prev = prevObjects.get(value);
    if (prev) {
      var alias = new Alias2(prev);
      ctx.aliasNodes.push(alias);
      return alias;
    }
    obj.value = value;
    prevObjects.set(value, obj);
  }
  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar(value) : value;
  if (tagName && obj.node instanceof Node2)
    obj.node.tag = tagName;
  return obj.node;
}
function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
  var tags2 = schemas2[schemaId.replace(/\W/g, "")];
  if (!tags2) {
    var keys = Object.keys(schemas2).map(function(key) {
      return JSON.stringify(key);
    }).join(", ");
    throw new Error('Unknown schema "'.concat(schemaId, '"; use one of ').concat(keys));
  }
  if (Array.isArray(customTags)) {
    var _iterator = _createForOfIteratorHelper(customTags), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var tag = _step.value;
        tags2 = tags2.concat(tag);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  for (var i = 0; i < tags2.length; ++i) {
    var _tag = tags2[i];
    if (typeof _tag === "string") {
      var tagObj = knownTags[_tag];
      if (!tagObj) {
        var _keys = Object.keys(knownTags).map(function(key) {
          return JSON.stringify(key);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(_tag, '"; use one of ').concat(_keys));
      }
      tags2[i] = tagObj;
    }
  }
  return tags2;
}
var map, seq, string, failsafe, intIdentify$2, intResolve$1, nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj, core, intIdentify$1, stringifyJSON, json, boolStringify, intIdentify3, yaml11, schemas, tags, sortMapEntriesByKey, Schema;
var init_Schema_e94716c8 = __esm({
  "node_modules/yaml/browser/dist/Schema-e94716c8.js"() {
    init_PlainValue_b8036b75();
    init_resolveSeq_492ab440();
    init_warnings_df54cb69();
    map = {
      createNode: createMap,
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveMap
    };
    seq = {
      createNode: createSeq,
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq
    };
    string = {
      identify: function identify7(value) {
        return typeof value === "string";
      },
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveString,
      stringify: function stringify3(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: strOptions
    };
    failsafe = [map, seq, string];
    intIdentify$2 = function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    };
    intResolve$1 = function intResolve(src, part, radix) {
      return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    };
    nullObj = {
      identify: function identify8(value) {
        return value == null;
      },
      createNode: function createNode(schema, value, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function resolve5() {
        return null;
      },
      options: nullOptions,
      stringify: function stringify4() {
        return nullOptions.nullStr;
      }
    };
    boolObj = {
      identify: function identify9(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: function resolve6(str) {
        return str[0] === "t" || str[0] === "T";
      },
      options: boolOptions,
      stringify: function stringify5(_ref) {
        var value = _ref.value;
        return value ? boolOptions.trueStr : boolOptions.falseStr;
      }
    };
    octObj = {
      identify: function identify10(value) {
        return intIdentify$2(value) && value >= 0;
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: function resolve7(str, oct) {
        return intResolve$1(str, oct, 8);
      },
      options: intOptions,
      stringify: function stringify6(node) {
        return intStringify$1(node, 8, "0o");
      }
    };
    intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: function resolve8(str) {
        return intResolve$1(str, str, 10);
      },
      options: intOptions,
      stringify: stringifyNumber
    };
    hexObj = {
      identify: function identify11(value) {
        return intIdentify$2(value) && value >= 0;
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: function resolve9(str, hex) {
        return intResolve$1(str, hex, 16);
      },
      options: intOptions,
      stringify: function stringify7(node) {
        return intStringify$1(node, 16, "0x");
      }
    };
    nanObj = {
      identify: function identify12(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: function resolve10(str, nan) {
        return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber
    };
    expObj = {
      identify: function identify13(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: function resolve11(str) {
        return parseFloat(str);
      },
      stringify: function stringify8(_ref2) {
        var value = _ref2.value;
        return Number(value).toExponential();
      }
    };
    floatObj = {
      identify: function identify14(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve: function resolve12(str, frac1, frac2) {
        var frac = frac1 || frac2;
        var node = new Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0")
          node.minFractionDigits = frac.length;
        return node;
      },
      stringify: stringifyNumber
    };
    core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    intIdentify$1 = function intIdentify2(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    };
    stringifyJSON = function stringifyJSON2(_ref) {
      var value = _ref.value;
      return JSON.stringify(value);
    };
    json = [map, seq, {
      identify: function identify15(value) {
        return typeof value === "string";
      },
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveString,
      stringify: stringifyJSON
    }, {
      identify: function identify16(value) {
        return value == null;
      },
      createNode: function createNode2(schema, value, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: function resolve13() {
        return null;
      },
      stringify: stringifyJSON
    }, {
      identify: function identify17(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: function resolve14(str) {
        return str === "true";
      },
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: function resolve15(str) {
        return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);
      },
      stringify: function stringify9(_ref2) {
        var value = _ref2.value;
        return intIdentify$1(value) ? value.toString() : JSON.stringify(value);
      }
    }, {
      identify: function identify18(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: function resolve16(str) {
        return parseFloat(str);
      },
      stringify: stringifyJSON
    }];
    json.scalarFallback = function(str) {
      throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
    };
    boolStringify = function boolStringify2(_ref) {
      var value = _ref.value;
      return value ? boolOptions.trueStr : boolOptions.falseStr;
    };
    intIdentify3 = function intIdentify4(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    };
    yaml11 = failsafe.concat([{
      identify: function identify19(value) {
        return value == null;
      },
      createNode: function createNode3(schema, value, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function resolve17() {
        return null;
      },
      options: nullOptions,
      stringify: function stringify10() {
        return nullOptions.nullStr;
      }
    }, {
      identify: function identify20(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: function resolve18() {
        return true;
      },
      options: boolOptions,
      stringify: boolStringify
    }, {
      identify: function identify21(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: function resolve19() {
        return false;
      },
      options: boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: function resolve20(str, sign, bin) {
        return intResolve2(sign, bin, 2);
      },
      stringify: function stringify11(node) {
        return intStringify(node, 2, "0b");
      }
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: function resolve21(str, sign, oct) {
        return intResolve2(sign, oct, 8);
      },
      stringify: function stringify12(node) {
        return intStringify(node, 8, "0");
      }
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: function resolve22(str, sign, abs) {
        return intResolve2(sign, abs, 10);
      },
      stringify: stringifyNumber
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: function resolve23(str, sign, hex) {
        return intResolve2(sign, hex, 16);
      },
      stringify: function stringify13(node) {
        return intStringify(node, 16, "0x");
      }
    }, {
      identify: function identify22(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: function resolve24(str, nan) {
        return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber
    }, {
      identify: function identify23(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: function resolve25(str) {
        return parseFloat(str.replace(/_/g, ""));
      },
      stringify: function stringify14(_ref2) {
        var value = _ref2.value;
        return Number(value).toExponential();
      }
    }, {
      identify: function identify24(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve: function resolve26(str, frac) {
        var node = new Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          var f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber
    }], binary, omap, pairs, set, intTime, floatTime, timestamp);
    schemas = {
      core,
      failsafe,
      json,
      yaml11
    };
    tags = {
      binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime,
      map,
      null: nullObj,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    sortMapEntriesByKey = function sortMapEntriesByKey2(a, b) {
      return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    };
    Schema = function() {
      function Schema2(_ref) {
        var customTags = _ref.customTags, merge = _ref.merge, schema = _ref.schema, sortMapEntries = _ref.sortMapEntries, deprecatedCustomTags = _ref.tags;
        _classCallCheck(this, Schema2);
        this.merge = !!merge;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
      }
      _createClass(Schema2, [{
        key: "createNode",
        value: function createNode$1(value, wrapScalars, tagName, ctx) {
          var baseCtx = {
            defaultPrefix: Schema2.defaultPrefix,
            schema: this,
            wrapScalars
          };
          var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
          return createNode4(value, tagName, createCtx);
        }
      }, {
        key: "createPair",
        value: function createPair(key, value, ctx) {
          if (!ctx)
            ctx = {
              wrapScalars: true
            };
          var k = this.createNode(key, ctx.wrapScalars, null, ctx);
          var v = this.createNode(value, ctx.wrapScalars, null, ctx);
          return new Pair(k, v);
        }
      }]);
      return Schema2;
    }();
    _defineProperty(Schema, "defaultPrefix", defaultTagPrefix);
    _defineProperty(Schema, "defaultTags", defaultTags);
  }
});

// node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  YAML: () => YAML
});
function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === "1.0") {
    var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv)
      return "!" + priv[1];
    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ""));
  }
  var p = doc.tagPrefixes.find(function(p2) {
    return tag.indexOf(p2.prefix) === 0;
  });
  if (!p) {
    var dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(function(p2) {
      return tag.indexOf(p2.prefix) === 0;
    });
  }
  if (!p)
    return tag[0] === "!" ? tag : "!<".concat(tag, ">");
  var suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, function(ch) {
    return {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }[ch];
  });
  return p.handle + suffix;
}
function getTagObject(tags2, item) {
  if (item instanceof Alias2)
    return Alias2;
  if (item.tag) {
    var match = tags2.filter(function(t) {
      return t.tag === item.tag;
    });
    if (match.length > 0)
      return match.find(function(t) {
        return t.format === item.format;
      }) || match[0];
  }
  var tagObj, obj;
  if (item instanceof Scalar) {
    obj = item.value;
    var _match = tags2.filter(function(t) {
      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;
    });
    tagObj = _match.find(function(t) {
      return t.format === item.format;
    }) || _match.find(function(t) {
      return !t.format;
    });
  } else {
    obj = item;
    tagObj = tags2.find(function(t) {
      return t.nodeClass && obj instanceof t.nodeClass;
    });
  }
  if (!tagObj) {
    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);
    throw new Error("Tag not resolved for ".concat(name, " value"));
  }
  return tagObj;
}
function stringifyProps(node, tagObj, _ref) {
  var anchors = _ref.anchors, doc = _ref.doc;
  var props = [];
  var anchor = doc.anchors.getName(node);
  if (anchor) {
    anchors[anchor] = node;
    props.push("&".concat(anchor));
  }
  if (node.tag) {
    props.push(stringifyTag(doc, node.tag));
  } else if (!tagObj.default) {
    props.push(stringifyTag(doc, tagObj.tag));
  }
  return props.join(" ");
}
function stringify$1(item, ctx, onComment, onChompKeep) {
  var _ctx$doc = ctx.doc, anchors = _ctx$doc.anchors, schema = _ctx$doc.schema;
  var tagObj;
  if (!(item instanceof Node2)) {
    var createCtx = {
      aliasNodes: [],
      onTagObj: function onTagObj(o) {
        return tagObj = o;
      },
      prevObjects: /* @__PURE__ */ new Map()
    };
    item = schema.createNode(item, true, null, createCtx);
    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var alias = _step.value;
        alias.source = alias.source.node;
        var name = anchors.getName(alias.source);
        if (!name) {
          name = anchors.newName();
          anchors.map[name] = alias.source;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  if (item instanceof Pair)
    return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj)
    tagObj = getTagObject(schema.tags, item);
  var props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  var str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return item instanceof Scalar || str[0] === "{" || str[0] === "[" ? "".concat(props, " ").concat(str) : "".concat(props, "\n").concat(ctx.indent).concat(str);
}
function parseContents(doc, contents) {
  var comments = {
    before: [],
    after: []
  };
  var body = void 0;
  var spaceBefore = false;
  var _iterator = _createForOfIteratorHelper(contents), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var node = _step.value;
      if (node.valueRange) {
        if (body !== void 0) {
          var msg = "Document contains trailing content not separated by a ... or --- line";
          doc.errors.push(new YAMLSyntaxError(node, msg));
          break;
        }
        var res = resolveNode(doc, node);
        if (spaceBefore) {
          res.spaceBefore = true;
          spaceBefore = false;
        }
        body = res;
      } else if (node.comment !== null) {
        var cc = body === void 0 ? comments.before : comments.after;
        cc.push(node.comment);
      } else if (node.type === Type.BLANK_LINE) {
        spaceBefore = true;
        if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
          doc.commentBefore = comments.before.join("\n");
          comments.before = [];
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  doc.contents = body || null;
  if (!body) {
    doc.comment = comments.before.concat(comments.after).join("\n") || null;
  } else {
    var cb = comments.before.join("\n");
    if (cb) {
      var cbNode = body instanceof Collection2 && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
    }
    doc.comment = comments.after.join("\n") || null;
  }
}
function resolveTagDirective(_ref, directive) {
  var tagPrefixes = _ref.tagPrefixes;
  var _directive$parameters = _slicedToArray(directive.parameters, 2), handle = _directive$parameters[0], prefix = _directive$parameters[1];
  if (!handle || !prefix) {
    var msg = "Insufficient parameters given for %TAG directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (tagPrefixes.some(function(p) {
    return p.handle === handle;
  })) {
    var _msg = "The %TAG directive must only be given at most once per handle in the same document.";
    throw new YAMLSemanticError(directive, _msg);
  }
  return {
    handle,
    prefix
  };
}
function resolveYamlDirective(doc, directive) {
  var _directive$parameters2 = _slicedToArray(directive.parameters, 1), version = _directive$parameters2[0];
  if (directive.name === "YAML:1.0")
    version = "1.0";
  if (!version) {
    var msg = "Insufficient parameters given for %YAML directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (!documentOptions[version]) {
    var v0 = doc.version || doc.options.version;
    var _msg2 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);
    doc.warnings.push(new YAMLWarning(directive, _msg2));
  }
  return version;
}
function parseDirectives(doc, directives, prevDoc) {
  var directiveComments = [];
  var hasDirectives = false;
  var _iterator = _createForOfIteratorHelper(directives), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var directive = _step.value;
      var comment = directive.comment, name = directive.name;
      switch (name) {
        case "TAG":
          try {
            doc.tagPrefixes.push(resolveTagDirective(doc, directive));
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        case "YAML":
        case "YAML:1.0":
          if (doc.version) {
            var msg = "The %YAML directive must only be given at most once per document.";
            doc.errors.push(new YAMLSemanticError(directive, msg));
          }
          try {
            doc.version = resolveYamlDirective(doc, directive);
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        default:
          if (name) {
            var _msg3 = "YAML only supports %TAG and %YAML directives, and not %".concat(name);
            doc.warnings.push(new YAMLWarning(directive, _msg3));
          }
      }
      if (comment)
        directiveComments.push(comment);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
    var copyTagPrefix = function copyTagPrefix2(_ref2) {
      var handle = _ref2.handle, prefix = _ref2.prefix;
      return {
        handle,
        prefix
      };
    };
    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }
  doc.commentBefore = directiveComments.join("\n") || null;
}
function assertCollection(contents) {
  if (contents instanceof Collection2)
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function createNode5(value) {
  var wrapScalars = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var tag = arguments.length > 2 ? arguments[2] : void 0;
  if (tag === void 0 && typeof wrapScalars === "string") {
    tag = wrapScalars;
    wrapScalars = true;
  }
  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);
  var schema = new Schema(options);
  return schema.createNode(value, wrapScalars, tag);
}
function parseAllDocuments(src, options) {
  var stream = [];
  var prev;
  var _iterator = _createForOfIteratorHelper(parse(src)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var cstDoc = _step.value;
      var doc = new Document2(options);
      doc.parse(cstDoc, prev);
      stream.push(doc);
      prev = doc;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return stream;
}
function parseDocument(src, options) {
  var cst = parse(src);
  var doc = new Document2(options).parse(cst[0]);
  if (cst.length > 1) {
    var errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
  }
  return doc;
}
function parse2(src, options) {
  var doc = parseDocument(src, options);
  doc.warnings.forEach(function(warning) {
    return warn(warning);
  });
  if (doc.errors.length > 0)
    throw doc.errors[0];
  return doc.toJSON();
}
function stringify15(value, options) {
  var doc = new Document2(options);
  doc.contents = value;
  return String(doc);
}
var defaultOptions, scalarOptions, documentOptions, Anchors, visit, listTagNames, Document$1, Document2, YAML;
var init_dist = __esm({
  "node_modules/yaml/browser/dist/index.js"() {
    init_PlainValue_b8036b75();
    init_parse_cst();
    init_resolveSeq_492ab440();
    init_Schema_e94716c8();
    init_warnings_df54cb69();
    defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      // TODO Set true in v2
      simpleKeys: false,
      version: "1.2"
    };
    scalarOptions = {
      get binary() {
        return binaryOptions;
      },
      set binary(opt) {
        Object.assign(binaryOptions, opt);
      },
      get bool() {
        return boolOptions;
      },
      set bool(opt) {
        Object.assign(boolOptions, opt);
      },
      get int() {
        return intOptions;
      },
      set int(opt) {
        Object.assign(intOptions, opt);
      },
      get null() {
        return nullOptions;
      },
      set null(opt) {
        Object.assign(nullOptions, opt);
      },
      get str() {
        return strOptions;
      },
      set str(opt) {
        Object.assign(strOptions, opt);
      }
    };
    documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: defaultTagPrefix
        }]
      }
    };
    Anchors = function() {
      function Anchors2(prefix) {
        _classCallCheck(this, Anchors2);
        _defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      _createClass(Anchors2, [{
        key: "createAlias",
        value: function createAlias(node, name) {
          this.setAnchor(node, name);
          return new Alias2(node);
        }
      }, {
        key: "createMergePair",
        value: function createMergePair() {
          var _this = this;
          var merge = new Merge();
          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          merge.value.items = sources.map(function(s) {
            if (s instanceof Alias2) {
              if (s.source instanceof YAMLMap)
                return s;
            } else if (s instanceof YAMLMap) {
              return _this.createAlias(s);
            }
            throw new Error("Merge sources must be Map nodes or their Aliases");
          });
          return merge;
        }
      }, {
        key: "getName",
        value: function getName(node) {
          var map2 = this.map;
          return Object.keys(map2).find(function(a) {
            return map2[a] === node;
          });
        }
      }, {
        key: "getNames",
        value: function getNames() {
          return Object.keys(this.map);
        }
      }, {
        key: "getNode",
        value: function getNode(name) {
          return this.map[name];
        }
      }, {
        key: "newName",
        value: function newName(prefix) {
          if (!prefix)
            prefix = this.prefix;
          var names = Object.keys(this.map);
          for (var i = 1; true; ++i) {
            var name = "".concat(prefix).concat(i);
            if (!names.includes(name))
              return name;
          }
        }
        // During parsing, map & aliases contain CST nodes
      }, {
        key: "resolveNodes",
        value: function resolveNodes() {
          var map2 = this.map, _cstAliases = this._cstAliases;
          Object.keys(map2).forEach(function(a) {
            map2[a] = map2[a].resolved;
          });
          _cstAliases.forEach(function(a) {
            a.source = a.source.resolved;
          });
          delete this._cstAliases;
        }
      }, {
        key: "setAnchor",
        value: function setAnchor(node, name) {
          if (node != null && !Anchors2.validAnchorNode(node)) {
            throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
          }
          if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
            throw new Error("Anchor names must not contain whitespace or control characters");
          }
          var map2 = this.map;
          var prev = node && Object.keys(map2).find(function(a) {
            return map2[a] === node;
          });
          if (prev) {
            if (!name) {
              return prev;
            } else if (prev !== name) {
              delete map2[prev];
              map2[name] = node;
            }
          } else {
            if (!name) {
              if (!node)
                return null;
              name = this.newName();
            }
            map2[name] = node;
          }
          return name;
        }
      }], [{
        key: "validAnchorNode",
        value: function validAnchorNode(node) {
          return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;
        }
      }]);
      return Anchors2;
    }();
    visit = function visit2(node, tags2) {
      if (node && _typeof(node) === "object") {
        var tag = node.tag;
        if (node instanceof Collection2) {
          if (tag)
            tags2[tag] = true;
          node.items.forEach(function(n) {
            return visit2(n, tags2);
          });
        } else if (node instanceof Pair) {
          visit2(node.key, tags2);
          visit2(node.value, tags2);
        } else if (node instanceof Scalar) {
          if (tag)
            tags2[tag] = true;
        }
      }
      return tags2;
    };
    listTagNames = function listTagNames2(node) {
      return Object.keys(visit(node, {}));
    };
    Document$1 = function() {
      function Document3(options) {
        _classCallCheck(this, Document3);
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      _createClass(Document3, [{
        key: "add",
        value: function add(value) {
          assertCollection(this.contents);
          return this.contents.add(value);
        }
      }, {
        key: "addIn",
        value: function addIn(path, value) {
          assertCollection(this.contents);
          this.contents.addIn(path, value);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          assertCollection(this.contents);
          return this.contents.delete(key);
        }
      }, {
        key: "deleteIn",
        value: function deleteIn(path) {
          if (isEmptyPath(path)) {
            if (this.contents == null)
              return false;
            this.contents = null;
            return true;
          }
          assertCollection(this.contents);
          return this.contents.deleteIn(path);
        }
      }, {
        key: "getDefaults",
        value: function getDefaults() {
          return Document3.defaults[this.version] || Document3.defaults[this.options.version] || {};
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          return this.contents instanceof Collection2 ? this.contents.get(key, keepScalar) : void 0;
        }
      }, {
        key: "getIn",
        value: function getIn(path, keepScalar) {
          if (isEmptyPath(path))
            return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;
          return this.contents instanceof Collection2 ? this.contents.getIn(path, keepScalar) : void 0;
        }
      }, {
        key: "has",
        value: function has(key) {
          return this.contents instanceof Collection2 ? this.contents.has(key) : false;
        }
      }, {
        key: "hasIn",
        value: function hasIn(path) {
          if (isEmptyPath(path))
            return this.contents !== void 0;
          return this.contents instanceof Collection2 ? this.contents.hasIn(path) : false;
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          assertCollection(this.contents);
          this.contents.set(key, value);
        }
      }, {
        key: "setIn",
        value: function setIn(path, value) {
          if (isEmptyPath(path))
            this.contents = value;
          else {
            assertCollection(this.contents);
            this.contents.setIn(path, value);
          }
        }
      }, {
        key: "setSchema",
        value: function setSchema(id, customTags) {
          if (!id && !customTags && this.schema)
            return;
          if (typeof id === "number")
            id = id.toFixed(1);
          if (id === "1.0" || id === "1.1" || id === "1.2") {
            if (this.version)
              this.version = id;
            else
              this.options.version = id;
            delete this.options.schema;
          } else if (id && typeof id === "string") {
            this.options.schema = id;
          }
          if (Array.isArray(customTags))
            this.options.customTags = customTags;
          var opt = Object.assign({}, this.getDefaults(), this.options);
          this.schema = new Schema(opt);
        }
      }, {
        key: "parse",
        value: function parse3(node, prevDoc) {
          if (this.options.keepCstNodes)
            this.cstNode = node;
          if (this.options.keepNodeTypes)
            this.type = "DOCUMENT";
          var _node$directives = node.directives, directives = _node$directives === void 0 ? [] : _node$directives, _node$contents = node.contents, contents = _node$contents === void 0 ? [] : _node$contents, directivesEndMarker = node.directivesEndMarker, error = node.error, valueRange = node.valueRange;
          if (error) {
            if (!error.source)
              error.source = this;
            this.errors.push(error);
          }
          parseDirectives(this, directives, prevDoc);
          if (directivesEndMarker)
            this.directivesEndMarker = true;
          this.range = valueRange ? [valueRange.start, valueRange.end] : null;
          this.setSchema();
          this.anchors._cstAliases = [];
          parseContents(this, contents);
          this.anchors.resolveNodes();
          if (this.options.prettyErrors) {
            var _iterator = _createForOfIteratorHelper(this.errors), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _error = _step.value;
                if (_error instanceof YAMLError)
                  _error.makePretty();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            var _iterator2 = _createForOfIteratorHelper(this.warnings), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var warn2 = _step2.value;
                if (warn2 instanceof YAMLError)
                  warn2.makePretty();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          return this;
        }
      }, {
        key: "listNonDefaultTags",
        value: function listNonDefaultTags() {
          return listTagNames(this.contents).filter(function(t) {
            return t.indexOf(Schema.defaultPrefix) !== 0;
          });
        }
      }, {
        key: "setTagPrefix",
        value: function setTagPrefix(handle, prefix) {
          if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
            throw new Error("Handle must start and end with !");
          if (prefix) {
            var prev = this.tagPrefixes.find(function(p) {
              return p.handle === handle;
            });
            if (prev)
              prev.prefix = prefix;
            else
              this.tagPrefixes.push({
                handle,
                prefix
              });
          } else {
            this.tagPrefixes = this.tagPrefixes.filter(function(p) {
              return p.handle !== handle;
            });
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(arg, onAnchor) {
          var _this = this;
          var _this$options = this.options, keepBlobsInJSON = _this$options.keepBlobsInJSON, mapAsMap = _this$options.mapAsMap, maxAliasCount = _this$options.maxAliasCount;
          var keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof Scalar));
          var ctx = {
            doc: this,
            indentStep: "  ",
            keep,
            mapAsMap: keep && !!mapAsMap,
            maxAliasCount,
            stringify: stringify$1
            // Requiring directly in Pair would create circular dependencies
          };
          var anchorNames = Object.keys(this.anchors.map);
          if (anchorNames.length > 0)
            ctx.anchors = new Map(anchorNames.map(function(name) {
              return [_this.anchors.map[name], {
                alias: [],
                aliasCount: 0,
                count: 1
              }];
            }));
          var res = toJSON(this.contents, arg, ctx);
          if (typeof onAnchor === "function" && ctx.anchors) {
            var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var _step3$value = _step3.value, count = _step3$value.count, _res = _step3$value.res;
                onAnchor(_res, count);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
          return res;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.errors.length > 0)
            throw new Error("Document with errors cannot be stringified");
          var indentSize = this.options.indent;
          if (!Number.isInteger(indentSize) || indentSize <= 0) {
            var s = JSON.stringify(indentSize);
            throw new Error('"indent" option must be a positive integer, not '.concat(s));
          }
          this.setSchema();
          var lines = [];
          var hasDirectives = false;
          if (this.version) {
            var vd = "%YAML 1.2";
            if (this.schema.name === "yaml-1.1") {
              if (this.version === "1.0")
                vd = "%YAML:1.0";
              else if (this.version === "1.1")
                vd = "%YAML 1.1";
            }
            lines.push(vd);
            hasDirectives = true;
          }
          var tagNames = this.listNonDefaultTags();
          this.tagPrefixes.forEach(function(_ref) {
            var handle = _ref.handle, prefix = _ref.prefix;
            if (tagNames.some(function(t) {
              return t.indexOf(prefix) === 0;
            })) {
              lines.push("%TAG ".concat(handle, " ").concat(prefix));
              hasDirectives = true;
            }
          });
          if (hasDirectives || this.directivesEndMarker)
            lines.push("---");
          if (this.commentBefore) {
            if (hasDirectives || !this.directivesEndMarker)
              lines.unshift("");
            lines.unshift(this.commentBefore.replace(/^/gm, "#"));
          }
          var ctx = {
            anchors: /* @__PURE__ */ Object.create(null),
            doc: this,
            indent: "",
            indentStep: " ".repeat(indentSize),
            stringify: stringify$1
            // Requiring directly in nodes would create circular dependencies
          };
          var chompKeep = false;
          var contentComment = null;
          if (this.contents) {
            if (this.contents instanceof Node2) {
              if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
                lines.push("");
              if (this.contents.commentBefore)
                lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
              ctx.forceBlockIndent = !!this.comment;
              contentComment = this.contents.comment;
            }
            var onChompKeep = contentComment ? null : function() {
              return chompKeep = true;
            };
            var body = stringify$1(this.contents, ctx, function() {
              return contentComment = null;
            }, onChompKeep);
            lines.push(addComment(body, "", contentComment));
          } else if (this.contents !== void 0) {
            lines.push(stringify$1(this.contents, ctx));
          }
          if (this.comment) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
              lines.push("");
            lines.push(this.comment.replace(/^/gm, "#"));
          }
          return lines.join("\n") + "\n";
        }
      }]);
      return Document3;
    }();
    _defineProperty(Document$1, "defaults", documentOptions);
    Document2 = function(_YAMLDocument) {
      _inherits(Document3, _YAMLDocument);
      var _super = _createSuper(Document3);
      function Document3(options) {
        _classCallCheck(this, Document3);
        return _super.call(this, Object.assign({}, defaultOptions, options));
      }
      return Document3;
    }(Document$1);
    YAML = {
      createNode: createNode5,
      defaultOptions,
      Document: Document2,
      parse: parse2,
      parseAllDocuments,
      parseCST: parse,
      parseDocument,
      scalarOptions,
      stringify: stringify15
    };
  }
});

// node_modules/yaml/browser/index.js
var require_browser2 = __commonJS({
  "node_modules/yaml/browser/index.js"(exports, module) {
    module.exports = (init_dist(), __toCommonJS(dist_exports)).YAML;
  }
});

// node_modules/cosmiconfig/dist/loaders.js
var require_loaders = __commonJS({
  "node_modules/cosmiconfig/dist/loaders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.loaders = void 0;
    var importFresh;
    var loadJs = function loadJs2(filepath) {
      if (importFresh === void 0) {
        importFresh = require_import_fresh();
      }
      const result = importFresh(filepath);
      return result;
    };
    var parseJson;
    var loadJson = function loadJson2(filepath, content) {
      if (parseJson === void 0) {
        parseJson = require_parse_json();
      }
      try {
        const result = parseJson(content);
        return result;
      } catch (error) {
        error.message = `JSON Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    var yaml;
    var loadYaml = function loadYaml2(filepath, content) {
      if (yaml === void 0) {
        yaml = require_browser2();
      }
      try {
        const result = yaml.parse(content, {
          prettyErrors: true
        });
        return result;
      } catch (error) {
        error.message = `YAML Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    var loaders = {
      loadJs,
      loadJson,
      loadYaml
    };
    exports.loaders = loaders;
  }
});

// node_modules/cosmiconfig/dist/getPropertyByPath.js
var require_getPropertyByPath = __commonJS({
  "node_modules/cosmiconfig/dist/getPropertyByPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPropertyByPath = getPropertyByPath;
    function getPropertyByPath(source, path) {
      if (typeof path === "string" && Object.prototype.hasOwnProperty.call(source, path)) {
        return source[path];
      }
      const parsedPath = typeof path === "string" ? path.split(".") : path;
      return parsedPath.reduce((previous, key) => {
        if (previous === void 0) {
          return previous;
        }
        return previous[key];
      }, source);
    }
  }
});

// node_modules/cosmiconfig/dist/ExplorerBase.js
var require_ExplorerBase = __commonJS({
  "node_modules/cosmiconfig/dist/ExplorerBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExplorerBase = void 0;
    exports.getExtensionDescription = getExtensionDescription;
    var _path = _interopRequireDefault(require_path());
    var _loaders = require_loaders();
    var _getPropertyByPath = require_getPropertyByPath();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerBase = class {
      constructor(options) {
        if (options.cache === true) {
          this.loadCache = /* @__PURE__ */ new Map();
          this.searchCache = /* @__PURE__ */ new Map();
        }
        this.config = options;
        this.validateConfig();
      }
      clearLoadCache() {
        if (this.loadCache) {
          this.loadCache.clear();
        }
      }
      clearSearchCache() {
        if (this.searchCache) {
          this.searchCache.clear();
        }
      }
      clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
      }
      validateConfig() {
        const config = this.config;
        config.searchPlaces.forEach((place) => {
          const loaderKey = _path.default.extname(place) || "noExt";
          const loader = config.loaders[loaderKey];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
      }
      shouldSearchStopWithResult(result) {
        if (result === null)
          return false;
        if (result.isEmpty && this.config.ignoreEmptySearchPlaces)
          return false;
        return true;
      }
      nextDirectoryToSearch(currentDir, currentResult) {
        if (this.shouldSearchStopWithResult(currentResult)) {
          return null;
        }
        const nextDir = nextDirUp(currentDir);
        if (nextDir === currentDir || currentDir === this.config.stopDir) {
          return null;
        }
        return nextDir;
      }
      loadPackageProp(filepath, content) {
        const parsedContent = _loaders.loaders.loadJson(filepath, content);
        const packagePropValue = (0, _getPropertyByPath.getPropertyByPath)(parsedContent, this.config.packageProp);
        return packagePropValue || null;
      }
      getLoaderEntryForFile(filepath) {
        if (_path.default.basename(filepath) === "package.json") {
          const loader2 = this.loadPackageProp.bind(this);
          return loader2;
        }
        const loaderKey = _path.default.extname(filepath) || "noExt";
        const loader = this.config.loaders[loaderKey];
        if (!loader) {
          throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);
        }
        return loader;
      }
      loadedContentToCosmiconfigResult(filepath, loadedContent) {
        if (loadedContent === null) {
          return null;
        }
        if (loadedContent === void 0) {
          return {
            filepath,
            config: void 0,
            isEmpty: true
          };
        }
        return {
          config: loadedContent,
          filepath
        };
      }
      validateFilePath(filepath) {
        if (!filepath) {
          throw new Error("load must pass a non-empty string");
        }
      }
    };
    exports.ExplorerBase = ExplorerBase;
    function nextDirUp(dir) {
      return _path.default.dirname(dir);
    }
    function getExtensionDescription(filepath) {
      const ext = _path.default.extname(filepath);
      return ext ? `extension "${ext}"` : "files without extensions";
    }
  }
});

// node_modules/cosmiconfig/dist/readFile.js
var require_readFile = __commonJS({
  "node_modules/cosmiconfig/dist/readFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readFile = readFile;
    exports.readFileSync = readFileSync;
    var _fs = _interopRequireDefault(require_fs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function fsReadFileAsync(pathname, encoding) {
      return new Promise((resolve27, reject) => {
        _fs.default.readFile(pathname, encoding, (error, contents) => {
          if (error) {
            reject(error);
            return;
          }
          resolve27(contents);
        });
      });
    }
    async function readFile(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = await fsReadFileAsync(filepath, "utf8");
        return content;
      } catch (error) {
        if (throwNotFound === false && (error.code === "ENOENT" || error.code === "EISDIR")) {
          return null;
        }
        throw error;
      }
    }
    function readFileSync(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = _fs.default.readFileSync(filepath, "utf8");
        return content;
      } catch (error) {
        if (throwNotFound === false && (error.code === "ENOENT" || error.code === "EISDIR")) {
          return null;
        }
        throw error;
      }
    }
  }
});

// node_modules/cosmiconfig/dist/cacheWrapper.js
var require_cacheWrapper = __commonJS({
  "node_modules/cosmiconfig/dist/cacheWrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cacheWrapper = cacheWrapper;
    exports.cacheWrapperSync = cacheWrapperSync;
    async function cacheWrapper(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = await fn();
      cache.set(key, result);
      return result;
    }
    function cacheWrapperSync(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = fn();
      cache.set(key, result);
      return result;
    }
  }
});

// node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/path-type/index.js"(exports) {
    "use strict";
    var { promisify } = require_util();
    var fs = require_fs();
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports.isFile = isType.bind(null, "stat", "isFile");
    exports.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/cosmiconfig/dist/getDirectory.js
var require_getDirectory = __commonJS({
  "node_modules/cosmiconfig/dist/getDirectory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getDirectory = getDirectory;
    exports.getDirectorySync = getDirectorySync;
    var _path = _interopRequireDefault(require_path());
    var _pathType = require_path_type();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function getDirectory(filepath) {
      const filePathIsDirectory = await (0, _pathType.isDirectory)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
    function getDirectorySync(filepath) {
      const filePathIsDirectory = (0, _pathType.isDirectorySync)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
  }
});

// node_modules/cosmiconfig/dist/Explorer.js
var require_Explorer = __commonJS({
  "node_modules/cosmiconfig/dist/Explorer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Explorer = void 0;
    var _path = _interopRequireDefault(require_path());
    var _ExplorerBase = require_ExplorerBase();
    var _readFile = require_readFile();
    var _cacheWrapper = require_cacheWrapper();
    var _getDirectory = require_getDirectory();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Explorer = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      async search(searchFrom = process.cwd()) {
        const startDirectory = await (0, _getDirectory.getDirectory)(searchFrom);
        const result = await this.searchFromDirectory(startDirectory);
        return result;
      }
      async searchFromDirectory(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run = async () => {
          const result = await this.searchDirectory(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectory(nextDir);
          }
          const transformResult = await this.config.transform(result);
          return transformResult;
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.searchCache, absoluteDir, run);
        }
        return run();
      }
      async searchDirectory(dir) {
        for await (const place of this.config.searchPlaces) {
          const placeResult = await this.loadSearchPlace(dir, place);
          if (this.shouldSearchStopWithResult(placeResult) === true) {
            return placeResult;
          }
        }
        return null;
      }
      async loadSearchPlace(dir, place) {
        const filepath = _path.default.join(dir, place);
        const fileContents = await (0, _readFile.readFile)(filepath);
        const result = await this.createCosmiconfigResult(filepath, fileContents);
        return result;
      }
      async loadFileContent(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        const loaderResult = await loader(filepath, content);
        return loaderResult;
      }
      async createCosmiconfigResult(filepath, content) {
        const fileContent = await this.loadFileContent(filepath, content);
        const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
        return result;
      }
      async load(filepath) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoad = async () => {
          const fileContents = await (0, _readFile.readFile)(absoluteFilePath, {
            throwNotFound: true
          });
          const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents);
          const transformResult = await this.config.transform(result);
          return transformResult;
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);
        }
        return runLoad();
      }
    };
    exports.Explorer = Explorer;
  }
});

// node_modules/cosmiconfig/dist/ExplorerSync.js
var require_ExplorerSync = __commonJS({
  "node_modules/cosmiconfig/dist/ExplorerSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExplorerSync = void 0;
    var _path = _interopRequireDefault(require_path());
    var _ExplorerBase = require_ExplorerBase();
    var _readFile = require_readFile();
    var _cacheWrapper = require_cacheWrapper();
    var _getDirectory = require_getDirectory();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerSync = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      searchSync(searchFrom = process.cwd()) {
        const startDirectory = (0, _getDirectory.getDirectorySync)(searchFrom);
        const result = this.searchFromDirectorySync(startDirectory);
        return result;
      }
      searchFromDirectorySync(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run = () => {
          const result = this.searchDirectorySync(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectorySync(nextDir);
          }
          const transformResult = this.config.transform(result);
          return transformResult;
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.searchCache, absoluteDir, run);
        }
        return run();
      }
      searchDirectorySync(dir) {
        for (const place of this.config.searchPlaces) {
          const placeResult = this.loadSearchPlaceSync(dir, place);
          if (this.shouldSearchStopWithResult(placeResult) === true) {
            return placeResult;
          }
        }
        return null;
      }
      loadSearchPlaceSync(dir, place) {
        const filepath = _path.default.join(dir, place);
        const content = (0, _readFile.readFileSync)(filepath);
        const result = this.createCosmiconfigResultSync(filepath, content);
        return result;
      }
      loadFileContentSync(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        const loaderResult = loader(filepath, content);
        return loaderResult;
      }
      createCosmiconfigResultSync(filepath, content) {
        const fileContent = this.loadFileContentSync(filepath, content);
        const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
        return result;
      }
      loadSync(filepath) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoadSync = () => {
          const content = (0, _readFile.readFileSync)(absoluteFilePath, {
            throwNotFound: true
          });
          const cosmiconfigResult = this.createCosmiconfigResultSync(absoluteFilePath, content);
          const transformResult = this.config.transform(cosmiconfigResult);
          return transformResult;
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.loadCache, absoluteFilePath, runLoadSync);
        }
        return runLoadSync();
      }
    };
    exports.ExplorerSync = ExplorerSync;
  }
});

// node_modules/cosmiconfig/dist/types.js
var require_types = __commonJS({
  "node_modules/cosmiconfig/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/cosmiconfig/dist/index.js
var require_dist = __commonJS({
  "node_modules/cosmiconfig/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cosmiconfig = cosmiconfig;
    exports.cosmiconfigSync = cosmiconfigSync;
    exports.defaultLoaders = void 0;
    var _os = _interopRequireDefault(require_os());
    var _Explorer = require_Explorer();
    var _ExplorerSync = require_ExplorerSync();
    var _loaders = require_loaders();
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cosmiconfig(moduleName, options = {}) {
      const normalizedOptions = normalizeOptions(moduleName, options);
      const explorer = new _Explorer.Explorer(normalizedOptions);
      return {
        search: explorer.search.bind(explorer),
        load: explorer.load.bind(explorer),
        clearLoadCache: explorer.clearLoadCache.bind(explorer),
        clearSearchCache: explorer.clearSearchCache.bind(explorer),
        clearCaches: explorer.clearCaches.bind(explorer)
      };
    }
    function cosmiconfigSync(moduleName, options = {}) {
      const normalizedOptions = normalizeOptions(moduleName, options);
      const explorerSync = new _ExplorerSync.ExplorerSync(normalizedOptions);
      return {
        search: explorerSync.searchSync.bind(explorerSync),
        load: explorerSync.loadSync.bind(explorerSync),
        clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
        clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
        clearCaches: explorerSync.clearCaches.bind(explorerSync)
      };
    }
    var defaultLoaders = Object.freeze({
      ".cjs": _loaders.loaders.loadJs,
      ".js": _loaders.loaders.loadJs,
      ".json": _loaders.loaders.loadJson,
      ".yaml": _loaders.loaders.loadYaml,
      ".yml": _loaders.loaders.loadYaml,
      noExt: _loaders.loaders.loadYaml
    });
    exports.defaultLoaders = defaultLoaders;
    var identity = function identity2(x) {
      return x;
    };
    function normalizeOptions(moduleName, options) {
      const defaults = {
        packageProp: moduleName,
        searchPlaces: ["package.json", `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.js`, `.${moduleName}rc.cjs`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.cjs`, `${moduleName}.config.js`, `${moduleName}.config.cjs`],
        ignoreEmptySearchPlaces: true,
        stopDir: _os.default.homedir(),
        cache: true,
        transform: identity,
        loaders: defaultLoaders
      };
      const normalizedOptions = {
        ...defaults,
        ...options,
        loaders: {
          ...defaults.loaders,
          ...options.loaders
        }
      };
      return normalizedOptions;
    }
  }
});

// node_modules/babel-plugin-macros/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/babel-plugin-macros/dist/index.js"(exports, module) {
    "use strict";
    var p = require_path();
    var resolve27 = require_resolve();
    var macrosRegex = /[./]macro(\.c?js)?$/;
    var testMacrosRegex = (v) => macrosRegex.test(v);
    var MacroError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MacroError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, this.constructor);
        } else if (!this.stack) {
          this.stack = new Error(message).stack;
        }
      }
    };
    var _configExplorer = null;
    function getConfigExplorer() {
      return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle
      require_dist().cosmiconfigSync("babel-plugin-macros", {
        searchPlaces: ["package.json", ".babel-plugin-macrosrc", ".babel-plugin-macrosrc.json", ".babel-plugin-macrosrc.yaml", ".babel-plugin-macrosrc.yml", ".babel-plugin-macrosrc.js", "babel-plugin-macros.config.js"],
        packageProp: "babelMacros"
      });
    }
    function createMacro(macro, options = {}) {
      if (options.configName === "options") {
        throw new Error(`You cannot use the configName "options". It is reserved for babel-plugin-macros.`);
      }
      macroWrapper.isBabelMacro = true;
      macroWrapper.options = options;
      return macroWrapper;
      function macroWrapper(args) {
        const {
          source,
          isBabelMacrosCall
        } = args;
        if (!isBabelMacrosCall) {
          throw new MacroError(`The macro you imported from "${source}" is being executed outside the context of compilation with babel-plugin-macros. This indicates that you don't have the babel plugin "babel-plugin-macros" configured correctly. Please see the documentation for how to configure babel-plugin-macros properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md`);
        }
        return macro(args);
      }
    }
    function nodeResolvePath(source, basedir) {
      return resolve27.sync(source, {
        basedir,
        extensions: [".js", ".ts", ".tsx", ".mjs", ".cjs", ".jsx"],
        // This is here to support the package being globally installed
        // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138
        paths: [p.resolve(__dirname, "../../")]
      });
    }
    function macrosPlugin(babel, {
      require: _require = __require,
      resolvePath = nodeResolvePath,
      isMacrosName = testMacrosRegex,
      ...options
    } = {}) {
      function interopRequire(path) {
        const o = _require(path);
        return o && o.__esModule && o.default ? o.default : o;
      }
      return {
        name: "macros",
        visitor: {
          Program(progPath, state) {
            progPath.traverse({
              ImportDeclaration(path) {
                const isMacros = looksLike(path, {
                  node: {
                    source: {
                      value: (v) => isMacrosName(v)
                    }
                  }
                });
                if (!isMacros) {
                  return;
                }
                const imports = path.node.specifiers.map((s) => ({
                  localName: s.local.name,
                  importedName: s.type === "ImportDefaultSpecifier" ? "default" : s.imported.name
                }));
                const source = path.node.source.value;
                const result = applyMacros({
                  path,
                  imports,
                  source,
                  state,
                  babel,
                  interopRequire,
                  resolvePath,
                  options
                });
                if (!result || !result.keepImports) {
                  path.remove();
                }
              },
              VariableDeclaration(path) {
                const isMacros = (child) => looksLike(child, {
                  node: {
                    init: {
                      callee: {
                        type: "Identifier",
                        name: "require"
                      },
                      arguments: (args) => args.length === 1 && isMacrosName(args[0].value)
                    }
                  }
                });
                path.get("declarations").filter(isMacros).forEach((child) => {
                  const imports = child.node.id.name ? [{
                    localName: child.node.id.name,
                    importedName: "default"
                  }] : child.node.id.properties.map((property) => ({
                    localName: property.value.name,
                    importedName: property.key.name
                  }));
                  const call = child.get("init");
                  const source = call.node.arguments[0].value;
                  const result = applyMacros({
                    path: call,
                    imports,
                    source,
                    state,
                    babel,
                    interopRequire,
                    resolvePath,
                    options
                  });
                  if (!result || !result.keepImports) {
                    child.remove();
                  }
                });
              }
            });
          }
        }
      };
    }
    function applyMacros({
      path,
      imports,
      source,
      state,
      babel,
      interopRequire,
      resolvePath,
      options
    }) {
      const {
        file: {
          opts: {
            filename = ""
          }
        }
      } = state;
      let hasReferences = false;
      const referencePathsByImportName = imports.reduce((byName, {
        importedName,
        localName
      }) => {
        const binding = path.scope.getBinding(localName);
        byName[importedName] = binding.referencePaths;
        hasReferences = hasReferences || Boolean(byName[importedName].length);
        return byName;
      }, {});
      const isRelative = source.indexOf(".") === 0;
      const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));
      const macro = interopRequire(requirePath);
      if (!macro.isBabelMacro) {
        throw new Error(`The macro imported from "${source}" must be wrapped in "createMacro" which you can get from "babel-plugin-macros". Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);
      }
      const config = getConfig(macro, filename, source, options);
      let result;
      try {
        state.file.scope.path.traverse({
          Identifier() {
          }
        });
        result = macro({
          references: referencePathsByImportName,
          source,
          state,
          babel,
          config,
          isBabelMacrosCall: true
        });
      } catch (error) {
        if (error.name === "MacroError") {
          throw error;
        }
        error.message = `${source}: ${error.message}`;
        if (!isRelative) {
          error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace(
            // remove everything after package name
            // @org/package/macro -> @org/package
            // package/macro      -> package
            /^((?:@[^/]+\/)?[^/]+).*/,
            "$1"
          )}`;
        }
        throw error;
      }
      return result;
    }
    function getConfigFromFile(configName, filename) {
      try {
        const loaded = getConfigExplorer().search(filename);
        if (loaded) {
          return {
            options: loaded.config[configName],
            path: loaded.filepath
          };
        }
      } catch (e) {
        return {
          error: e
        };
      }
      return {};
    }
    function getConfigFromOptions(configName, options) {
      if (options.hasOwnProperty(configName)) {
        if (options[configName] && typeof options[configName] !== "object") {
          console.error(`The macro plugin options' ${configName} property was not an object or null.`);
        } else {
          return {
            options: options[configName]
          };
        }
      }
      return {};
    }
    function getConfig(macro, filename, source, options) {
      const {
        configName
      } = macro.options;
      if (configName) {
        const fileConfig = getConfigFromFile(configName, filename);
        const optionsConfig = getConfigFromOptions(configName, options);
        if (optionsConfig.options === void 0 && fileConfig.options === void 0 && fileConfig.error !== void 0) {
          console.error(`There was an error trying to load the config "${configName}" for the macro imported from "${source}. Please see the error thrown for more information.`);
          throw fileConfig.error;
        }
        if (fileConfig.options !== void 0 && optionsConfig.options !== void 0 && typeof fileConfig.options !== "object") {
          throw new Error(`${fileConfig.path} specified a ${configName} config of type ${typeof optionsConfig.options}, but the the macros plugin's options.${configName} did contain an object. Both configs must contain objects for their options to be mergeable.`);
        }
        return {
          ...optionsConfig.options,
          ...fileConfig.options
        };
      }
      return void 0;
    }
    function getFullFilename(filename) {
      if (p.isAbsolute(filename)) {
        return filename;
      }
      return p.join(process.cwd(), filename);
    }
    function looksLike(a, b) {
      return a && b && Object.keys(b).every((bKey) => {
        const bVal = b[bKey];
        const aVal = a[bKey];
        if (typeof bVal === "function") {
          return bVal(aVal);
        }
        return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);
      });
    }
    function isPrimitive(val) {
      return val == null || /^[sbn]/.test(typeof val);
    }
    module.exports = macrosPlugin;
    Object.assign(module.exports, {
      createMacro,
      MacroError
    });
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys = Object.keys(expected);
      for (const key of keys) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "") {
      if (warnings.has(oldName))
        return;
      warnings.add(oldName);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace)
        return {
          internal: false,
          trace: ""
        };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAccessor = isAccessor;
    exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports.isArgumentPlaceholder = isArgumentPlaceholder;
    exports.isArrayExpression = isArrayExpression;
    exports.isArrayPattern = isArrayPattern;
    exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports.isArrowFunctionExpression = isArrowFunctionExpression;
    exports.isAssignmentExpression = isAssignmentExpression;
    exports.isAssignmentPattern = isAssignmentPattern;
    exports.isAwaitExpression = isAwaitExpression;
    exports.isBigIntLiteral = isBigIntLiteral;
    exports.isBinary = isBinary;
    exports.isBinaryExpression = isBinaryExpression;
    exports.isBindExpression = isBindExpression;
    exports.isBlock = isBlock;
    exports.isBlockParent = isBlockParent;
    exports.isBlockStatement = isBlockStatement;
    exports.isBooleanLiteral = isBooleanLiteral;
    exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports.isBreakStatement = isBreakStatement;
    exports.isCallExpression = isCallExpression;
    exports.isCatchClause = isCatchClause;
    exports.isClass = isClass;
    exports.isClassAccessorProperty = isClassAccessorProperty;
    exports.isClassBody = isClassBody;
    exports.isClassDeclaration = isClassDeclaration;
    exports.isClassExpression = isClassExpression;
    exports.isClassImplements = isClassImplements;
    exports.isClassMethod = isClassMethod;
    exports.isClassPrivateMethod = isClassPrivateMethod;
    exports.isClassPrivateProperty = isClassPrivateProperty;
    exports.isClassProperty = isClassProperty;
    exports.isCompletionStatement = isCompletionStatement;
    exports.isConditional = isConditional;
    exports.isConditionalExpression = isConditionalExpression;
    exports.isContinueStatement = isContinueStatement;
    exports.isDebuggerStatement = isDebuggerStatement;
    exports.isDecimalLiteral = isDecimalLiteral;
    exports.isDeclaration = isDeclaration;
    exports.isDeclareClass = isDeclareClass;
    exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports.isDeclareFunction = isDeclareFunction;
    exports.isDeclareInterface = isDeclareInterface;
    exports.isDeclareModule = isDeclareModule;
    exports.isDeclareModuleExports = isDeclareModuleExports;
    exports.isDeclareOpaqueType = isDeclareOpaqueType;
    exports.isDeclareTypeAlias = isDeclareTypeAlias;
    exports.isDeclareVariable = isDeclareVariable;
    exports.isDeclaredPredicate = isDeclaredPredicate;
    exports.isDecorator = isDecorator;
    exports.isDirective = isDirective;
    exports.isDirectiveLiteral = isDirectiveLiteral;
    exports.isDoExpression = isDoExpression;
    exports.isDoWhileStatement = isDoWhileStatement;
    exports.isEmptyStatement = isEmptyStatement;
    exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports.isEnumBody = isEnumBody;
    exports.isEnumBooleanBody = isEnumBooleanBody;
    exports.isEnumBooleanMember = isEnumBooleanMember;
    exports.isEnumDeclaration = isEnumDeclaration;
    exports.isEnumDefaultedMember = isEnumDefaultedMember;
    exports.isEnumMember = isEnumMember;
    exports.isEnumNumberBody = isEnumNumberBody;
    exports.isEnumNumberMember = isEnumNumberMember;
    exports.isEnumStringBody = isEnumStringBody;
    exports.isEnumStringMember = isEnumStringMember;
    exports.isEnumSymbolBody = isEnumSymbolBody;
    exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports.isExportAllDeclaration = isExportAllDeclaration;
    exports.isExportDeclaration = isExportDeclaration;
    exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports.isExportNamedDeclaration = isExportNamedDeclaration;
    exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports.isExportSpecifier = isExportSpecifier;
    exports.isExpression = isExpression;
    exports.isExpressionStatement = isExpressionStatement;
    exports.isExpressionWrapper = isExpressionWrapper;
    exports.isFile = isFile;
    exports.isFlow = isFlow;
    exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports.isFlowDeclaration = isFlowDeclaration;
    exports.isFlowPredicate = isFlowPredicate;
    exports.isFlowType = isFlowType;
    exports.isFor = isFor;
    exports.isForInStatement = isForInStatement;
    exports.isForOfStatement = isForOfStatement;
    exports.isForStatement = isForStatement;
    exports.isForXStatement = isForXStatement;
    exports.isFunction = isFunction;
    exports.isFunctionDeclaration = isFunctionDeclaration;
    exports.isFunctionExpression = isFunctionExpression;
    exports.isFunctionParent = isFunctionParent;
    exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports.isFunctionTypeParam = isFunctionTypeParam;
    exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports.isIdentifier = isIdentifier;
    exports.isIfStatement = isIfStatement;
    exports.isImmutable = isImmutable;
    exports.isImport = isImport;
    exports.isImportAttribute = isImportAttribute;
    exports.isImportDeclaration = isImportDeclaration;
    exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports.isImportSpecifier = isImportSpecifier;
    exports.isIndexedAccessType = isIndexedAccessType;
    exports.isInferredPredicate = isInferredPredicate;
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    exports.isInterfaceExtends = isInterfaceExtends;
    exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports.isInterpreterDirective = isInterpreterDirective;
    exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports.isJSX = isJSX;
    exports.isJSXAttribute = isJSXAttribute;
    exports.isJSXClosingElement = isJSXClosingElement;
    exports.isJSXClosingFragment = isJSXClosingFragment;
    exports.isJSXElement = isJSXElement;
    exports.isJSXEmptyExpression = isJSXEmptyExpression;
    exports.isJSXExpressionContainer = isJSXExpressionContainer;
    exports.isJSXFragment = isJSXFragment;
    exports.isJSXIdentifier = isJSXIdentifier;
    exports.isJSXMemberExpression = isJSXMemberExpression;
    exports.isJSXNamespacedName = isJSXNamespacedName;
    exports.isJSXOpeningElement = isJSXOpeningElement;
    exports.isJSXOpeningFragment = isJSXOpeningFragment;
    exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports.isJSXSpreadChild = isJSXSpreadChild;
    exports.isJSXText = isJSXText;
    exports.isLVal = isLVal;
    exports.isLabeledStatement = isLabeledStatement;
    exports.isLiteral = isLiteral;
    exports.isLogicalExpression = isLogicalExpression;
    exports.isLoop = isLoop;
    exports.isMemberExpression = isMemberExpression;
    exports.isMetaProperty = isMetaProperty;
    exports.isMethod = isMethod;
    exports.isMiscellaneous = isMiscellaneous;
    exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports.isModuleDeclaration = isModuleDeclaration;
    exports.isModuleExpression = isModuleExpression;
    exports.isModuleSpecifier = isModuleSpecifier;
    exports.isNewExpression = isNewExpression;
    exports.isNoop = isNoop;
    exports.isNullLiteral = isNullLiteral;
    exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports.isNumberLiteral = isNumberLiteral;
    exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports.isNumericLiteral = isNumericLiteral;
    exports.isObjectExpression = isObjectExpression;
    exports.isObjectMember = isObjectMember;
    exports.isObjectMethod = isObjectMethod;
    exports.isObjectPattern = isObjectPattern;
    exports.isObjectProperty = isObjectProperty;
    exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports.isObjectTypeIndexer = isObjectTypeIndexer;
    exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports.isObjectTypeProperty = isObjectTypeProperty;
    exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports.isOpaqueType = isOpaqueType;
    exports.isOptionalCallExpression = isOptionalCallExpression;
    exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports.isOptionalMemberExpression = isOptionalMemberExpression;
    exports.isParenthesizedExpression = isParenthesizedExpression;
    exports.isPattern = isPattern;
    exports.isPatternLike = isPatternLike;
    exports.isPipelineBareFunction = isPipelineBareFunction;
    exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports.isPipelineTopicExpression = isPipelineTopicExpression;
    exports.isPlaceholder = isPlaceholder;
    exports.isPrivate = isPrivate;
    exports.isPrivateName = isPrivateName;
    exports.isProgram = isProgram;
    exports.isProperty = isProperty;
    exports.isPureish = isPureish;
    exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports.isRecordExpression = isRecordExpression;
    exports.isRegExpLiteral = isRegExpLiteral;
    exports.isRegexLiteral = isRegexLiteral;
    exports.isRestElement = isRestElement;
    exports.isRestProperty = isRestProperty;
    exports.isReturnStatement = isReturnStatement;
    exports.isScopable = isScopable;
    exports.isSequenceExpression = isSequenceExpression;
    exports.isSpreadElement = isSpreadElement;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStandardized = isStandardized;
    exports.isStatement = isStatement;
    exports.isStaticBlock = isStaticBlock;
    exports.isStringLiteral = isStringLiteral;
    exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports.isStringTypeAnnotation = isStringTypeAnnotation;
    exports.isSuper = isSuper;
    exports.isSwitchCase = isSwitchCase;
    exports.isSwitchStatement = isSwitchStatement;
    exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports.isTSAnyKeyword = isTSAnyKeyword;
    exports.isTSArrayType = isTSArrayType;
    exports.isTSAsExpression = isTSAsExpression;
    exports.isTSBaseType = isTSBaseType;
    exports.isTSBigIntKeyword = isTSBigIntKeyword;
    exports.isTSBooleanKeyword = isTSBooleanKeyword;
    exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports.isTSConditionalType = isTSConditionalType;
    exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports.isTSConstructorType = isTSConstructorType;
    exports.isTSDeclareFunction = isTSDeclareFunction;
    exports.isTSDeclareMethod = isTSDeclareMethod;
    exports.isTSEntityName = isTSEntityName;
    exports.isTSEnumDeclaration = isTSEnumDeclaration;
    exports.isTSEnumMember = isTSEnumMember;
    exports.isTSExportAssignment = isTSExportAssignment;
    exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports.isTSExternalModuleReference = isTSExternalModuleReference;
    exports.isTSFunctionType = isTSFunctionType;
    exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports.isTSImportType = isTSImportType;
    exports.isTSIndexSignature = isTSIndexSignature;
    exports.isTSIndexedAccessType = isTSIndexedAccessType;
    exports.isTSInferType = isTSInferType;
    exports.isTSInstantiationExpression = isTSInstantiationExpression;
    exports.isTSInterfaceBody = isTSInterfaceBody;
    exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports.isTSIntersectionType = isTSIntersectionType;
    exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports.isTSLiteralType = isTSLiteralType;
    exports.isTSMappedType = isTSMappedType;
    exports.isTSMethodSignature = isTSMethodSignature;
    exports.isTSModuleBlock = isTSModuleBlock;
    exports.isTSModuleDeclaration = isTSModuleDeclaration;
    exports.isTSNamedTupleMember = isTSNamedTupleMember;
    exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports.isTSNeverKeyword = isTSNeverKeyword;
    exports.isTSNonNullExpression = isTSNonNullExpression;
    exports.isTSNullKeyword = isTSNullKeyword;
    exports.isTSNumberKeyword = isTSNumberKeyword;
    exports.isTSObjectKeyword = isTSObjectKeyword;
    exports.isTSOptionalType = isTSOptionalType;
    exports.isTSParameterProperty = isTSParameterProperty;
    exports.isTSParenthesizedType = isTSParenthesizedType;
    exports.isTSPropertySignature = isTSPropertySignature;
    exports.isTSQualifiedName = isTSQualifiedName;
    exports.isTSRestType = isTSRestType;
    exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports.isTSStringKeyword = isTSStringKeyword;
    exports.isTSSymbolKeyword = isTSSymbolKeyword;
    exports.isTSThisType = isTSThisType;
    exports.isTSTupleType = isTSTupleType;
    exports.isTSType = isTSType;
    exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports.isTSTypeAnnotation = isTSTypeAnnotation;
    exports.isTSTypeAssertion = isTSTypeAssertion;
    exports.isTSTypeElement = isTSTypeElement;
    exports.isTSTypeLiteral = isTSTypeLiteral;
    exports.isTSTypeOperator = isTSTypeOperator;
    exports.isTSTypeParameter = isTSTypeParameter;
    exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports.isTSTypePredicate = isTSTypePredicate;
    exports.isTSTypeQuery = isTSTypeQuery;
    exports.isTSTypeReference = isTSTypeReference;
    exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports.isTSUnionType = isTSUnionType;
    exports.isTSUnknownKeyword = isTSUnknownKeyword;
    exports.isTSVoidKeyword = isTSVoidKeyword;
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports.isTemplateElement = isTemplateElement;
    exports.isTemplateLiteral = isTemplateLiteral;
    exports.isTerminatorless = isTerminatorless;
    exports.isThisExpression = isThisExpression;
    exports.isThisTypeAnnotation = isThisTypeAnnotation;
    exports.isThrowStatement = isThrowStatement;
    exports.isTopicReference = isTopicReference;
    exports.isTryStatement = isTryStatement;
    exports.isTupleExpression = isTupleExpression;
    exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports.isTypeAlias = isTypeAlias;
    exports.isTypeAnnotation = isTypeAnnotation;
    exports.isTypeCastExpression = isTypeCastExpression;
    exports.isTypeParameter = isTypeParameter;
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports.isTypeScript = isTypeScript;
    exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports.isUnaryExpression = isUnaryExpression;
    exports.isUnaryLike = isUnaryLike;
    exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports.isUpdateExpression = isUpdateExpression;
    exports.isUserWhitespacable = isUserWhitespacable;
    exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports.isVariableDeclaration = isVariableDeclaration;
    exports.isVariableDeclarator = isVariableDeclarator;
    exports.isVariance = isVariance;
    exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports.isWhile = isWhile;
    exports.isWhileStatement = isWhileStatement;
    exports.isWithStatement = isWithStatement;
    exports.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAssignmentExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AssignmentExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBinaryExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BinaryExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterpreterDirective(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterpreterDirective") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDirective(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Directive") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDirectiveLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DirectiveLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBlockStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BlockStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBreakStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BreakStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isCallExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "CallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isCatchClause(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "CatchClause") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isConditionalExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ConditionalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isContinueStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ContinueStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDebuggerStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DebuggerStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDoWhileStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DoWhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEmptyStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EmptyStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExpressionStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExpressionStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFile(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "File") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForInStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForInStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Identifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIfStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "IfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLabeledStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "LabeledStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStringLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumericLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumericLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNullLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NullLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBooleanLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BooleanLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRegExpLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RegExpLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLogicalExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMemberExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "MemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNewExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NewExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isProgram(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Program") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRestElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RestElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isReturnStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ReturnStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSequenceExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SequenceExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isParenthesizedExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ParenthesizedExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSwitchCase(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SwitchCase") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSwitchStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SwitchStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isThisExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ThisExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isThrowStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTryStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TryStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUnaryExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UnaryExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUpdateExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UpdateExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVariableDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "VariableDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVariableDeclarator(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "VariableDeclarator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isWhileStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "WhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isWithStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "WithStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAssignmentPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AssignmentPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArrayPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrowFunctionExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportAllDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportDefaultDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForOfStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportNamespaceSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMetaProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "MetaProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSpreadElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SpreadElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSuper(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Super") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TaggedTemplateExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTemplateElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TemplateElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTemplateLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TemplateLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isYieldExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "YieldExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAwaitExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImport(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Import") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBigIntLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BigIntLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportNamespaceSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OptionalMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOptionalCallExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OptionalCallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassAccessorProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassAccessorProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassPrivateProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassPrivateMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPrivateName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PrivateName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStaticBlock(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StaticBlock") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AnyTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BooleanTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BooleanLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NullLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassImplements(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassImplements") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareClass(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareClass") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareInterface(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareInterface") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareModule(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareModule") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareModuleExports(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareModuleExports") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareTypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareOpaqueType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareVariable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareVariable") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareExportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareExportAllDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclaredPredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclaredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExistsTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionTypeParam(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionTypeParam") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "GenericTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInferredPredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterfaceExtends(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterfaceExtends") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterfaceDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterfaceTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "IntersectionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "MixedTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EmptyTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NullableTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumberLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumberTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeInternalSlot") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeCallProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeIndexer") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOpaqueType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OpaqueType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "QualifiedTypeIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SymbolTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ThisTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TupleTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeofTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeAlias(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeCastExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeParameter(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeParameter") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeParameterDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeParameterInstantiation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UnionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVariance(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Variance") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumBooleanBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumBooleanBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumNumberBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumNumberBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumStringBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumStringBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumSymbolBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumBooleanMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumBooleanMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumNumberMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumNumberMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumStringMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumStringMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIndexedAccessType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "IndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXAttribute(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXClosingElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXClosingElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXEmptyExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXExpressionContainer") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXSpreadChild(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXSpreadChild") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXMemberExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXNamespacedName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXNamespacedName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXOpeningElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXOpeningElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXSpreadAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXText(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXText") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXFragment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXOpeningFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXClosingFragment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNoop(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Noop") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPlaceholder(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Placeholder") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "V8IntrinsicIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArgumentPlaceholder") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBindExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BindExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportAttribute(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDecorator(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Decorator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDoExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DoExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRecordExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RecordExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTupleExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TupleExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDecimalLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DecimalLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isModuleExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ModuleExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTopicReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TopicReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PipelineTopicExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPipelineBareFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PipelineBareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PipelinePrimaryTopicReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSParameterProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSParameterProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSDeclareFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSDeclareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSDeclareMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSDeclareMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSQualifiedName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSQualifiedName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSCallSignatureDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSConstructSignatureDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSPropertySignature(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSPropertySignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSMethodSignature(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSMethodSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIndexSignature(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSAnyKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSAnyKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSBooleanKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSBigIntKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIntrinsicKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNeverKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNeverKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNullKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNullKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNumberKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNumberKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSObjectKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSObjectKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSStringKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSStringKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSSymbolKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSUndefinedKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSUnknownKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSVoidKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSVoidKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSThisType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSThisType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSFunctionType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSFunctionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSConstructorType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSConstructorType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypePredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypePredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeQuery(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeQuery") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSArrayType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSArrayType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTupleType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTupleType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSOptionalType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSOptionalType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSRestType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSRestType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNamedTupleMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSUnionType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSUnionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIntersectionType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIntersectionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSConditionalType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSConditionalType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInferType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInferType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSParenthesizedType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSParenthesizedType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeOperator(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeOperator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSMappedType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSMappedType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSLiteralType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSExpressionWithTypeArguments") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInterfaceDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInterfaceBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInterfaceBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeAliasDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInstantiationExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInstantiationExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSAsExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSAsExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSSatisfiesExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSSatisfiesExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeAssertion(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeAssertion") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSEnumDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSEnumMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSEnumMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSModuleDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSModuleBlock(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSModuleBlock") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSImportType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSImportType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSImportEqualsDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSExternalModuleReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNonNullExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNonNullExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSExportAssignment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSExportAssignment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNamespaceExportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeParameterInstantiation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeParameterDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeParameter(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeParameter") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStandardized(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBinary(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isScopable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBlockParent(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBlock(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTerminatorless(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isCompletionStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isConditional(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLoop(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isWhile(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExpressionWrapper(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFor(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForXStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionParent(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPureish(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPatternLike(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLVal(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSEntityName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImmutable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUserWhitespacable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUnaryLike(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClass(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isModuleSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAccessor(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ClassAccessorProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPrivate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlow(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowPredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSX(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMiscellaneous(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeScript(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSBaseType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumberLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RegexLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRestProperty(node, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RestProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node, opts);
    }
  }
});

// node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matchesPattern;
    var _generated = require_generated();
    function matchesPattern(member, match, allowPartial) {
      if (!(0, _generated.isMemberExpression)(member))
        return false;
      const parts = Array.isArray(match) ? match : match.split(".");
      const nodes = [];
      let node;
      for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length)
        return false;
      if (!allowPartial && nodes.length > parts.length)
        return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node2 = nodes[j];
        let value;
        if ((0, _generated.isIdentifier)(node2)) {
          value = node2.name;
        } else if ((0, _generated.isStringLiteral)(node2)) {
          value = node2.value;
        } else if ((0, _generated.isThisExpression)(node2)) {
          value = "this";
        } else {
          return false;
        }
        if (parts[i] !== value)
          return false;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      const parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = isReactComponent;
    exports.default = _default;
  }
});

// node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS({
  "node_modules/to-fast-properties/index.js"(exports, module) {
    "use strict";
    var fastProto = null;
    function FastObject(o) {
      if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
      }
      fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o;
      return new FastObject();
    }
    FastObject();
    module.exports = function toFastproperties(o) {
      return FastObject(o);
    };
  }
});

// node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "node_modules/@babel/types/lib/validators/isType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isType;
    var _definitions = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (_definitions.ALIAS_KEYS[targetType])
        return false;
      const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (const alias of aliases) {
          if (nodeType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPlaceholderType;
    var _definitions = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType)
        return true;
      const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "node_modules/@babel/types/lib/validators/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = is;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _definitions = require_definitions();
    function is(type, node, opts) {
      if (!node)
        return false;
      const matches = (0, _isType.default)(node.type, type);
      if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node.expectedNode, type);
        }
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
  }
});

// node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib();
    function isValidIdentifier(name, reserved = true) {
      if (typeof name !== "string")
        return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name);
    }
  }
});

// node_modules/@babel/helper-string-parser/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readCodePoint = readCodePoint;
    exports.readInt = readInt;
    exports.readStringContents = readStringContents;
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          ({
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code;
      if (ch === 123) {
        ++pos;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code,
        pos
      };
    }
  }
});

// node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/@babel/types/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
    var FLATTENABLE_KEYS = ["body", "expressions"];
    exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
    var FOR_INIT_KEYS = ["left", "init"];
    exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
    var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    exports.COMMENT_KEYS = COMMENT_KEYS;
    var LOGICAL_OPERATORS = ["||", "&&", "??"];
    exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
    var UPDATE_OPERATORS = ["++", "--"];
    exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
    var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
    var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
    var COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
    var BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
    var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
    var BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    exports.BINARY_OPERATORS = BINARY_OPERATORS;
    var ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
    var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
    var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
    var STRING_UNARY_OPERATORS = ["typeof"];
    exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
    var UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    exports.UNARY_OPERATORS = UNARY_OPERATORS;
    var INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    exports.INHERIT_KEYS = INHERIT_KEYS;
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
    var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
  }
});

// node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
  "node_modules/@babel/types/lib/definitions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.assertEach = assertEach;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertNodeType = assertNodeType;
    exports.assertOneOf = assertOneOf;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.assertShape = assertShape;
    exports.assertValueType = assertValueType;
    exports.chain = chain;
    exports.default = defineType;
    exports.defineAliasedType = defineAliasedType;
    exports.typeIs = typeIs;
    exports.validate = validate;
    exports.validateArrayOfType = validateArrayOfType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = {};
    exports.VISITOR_KEYS = VISITOR_KEYS;
    var ALIAS_KEYS = {};
    exports.ALIAS_KEYS = ALIAS_KEYS;
    var FLIPPED_ALIAS_KEYS = {};
    exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
    var NODE_FIELDS = {};
    exports.NODE_FIELDS = NODE_FIELDS;
    var BUILDER_KEYS = {};
    exports.BUILDER_KEYS = BUILDER_KEYS;
    var DEPRECATED_KEYS = {};
    exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
    var NODE_PARENT_VALIDATIONS = {};
    exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
    }
    function validateType(typeName) {
      return validate(typeIs(typeName));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val))
          return;
        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node, subkey, v);
          if (process.env.BABEL_TYPES_8_BREAKING)
            (0, _validate.validateChild)(node, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate2(node, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values;
      return validate2;
    }
    function assertNodeType(...types) {
      function validate2(node, key, val) {
        for (const type of types) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeTypes = types;
      return validate2;
    }
    function assertNodeOrValueType(...types) {
      function validate2(node, key, val) {
        for (const type of types) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types;
      return validate2;
    }
    function assertValueType(type) {
      function validate2(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) {
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
      }
      validate2.type = type;
      return validate2;
    }
    function assertShape(shape) {
      function validate2(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node) {
        var _current;
        let current = node;
        while (node) {
          const {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional)
              return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional)
              return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns) {
      function validate2(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate2.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    var validFieldKeys = ["default", "optional", "validate"];
    var store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$, _defined;
          if (opts.inherits)
            defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          (_defined = defined) != null ? _defined : defined = [];
          opts.aliases = defined;
        }
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (validTypeOpts.indexOf(k) === -1) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && builder.indexOf(key) === -1) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (validFieldKeys.indexOf(k) === -1) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      store[type] = opts;
    }
  }
});

// node_modules/@babel/types/lib/definitions/core.js
var require_core4 = __commonJS({
  "node_modules/@babel/types/lib/definitions/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    var _helperStringParser = require_lib4();
    var _constants = require_constants();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertValueType)("string");
            }
            const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.operator === "in" ? inOp : expression;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
      },
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return () => {
          };
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          }))
        }
      }),
      validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /\.(\w+)$/.exec(key);
        if (!match)
          return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp))
            return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
            return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp))
            return;
          if ((0, _is.default)("Method", parent, nonComp))
            return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent))
            return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node
          }))
            return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node
          }))
            return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      }
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("number")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            const invalid = /[^gimsuy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: {
          validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, {
            type: "boolean"
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !(0, _is.default)("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          default: false
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate(parent, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match)
          throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index] = match;
        if (parent[listKey].length > +index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      }
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          }))
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using")
        },
        declarations: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
      },
      validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ForXStatement", parent, {
          left: node
        }))
          return;
        if (node.declarations.length !== 1) {
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        }
      }
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("LVal");
            }
            const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
            const without = (0, _utils.assertNodeType)("Identifier");
            return function(node, key, val) {
              const validator = node.init ? normal : without;
              validator(node, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
        }
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("ExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
      }
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
          default: [],
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return sourced;
            return function(node, key, val) {
              const validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            };
          }()))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return function(node, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            };
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      visitor: ["specifiers", "source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: {
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        specifiers: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          }))
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
      },
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "quasi", "typeParameters"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled)
              throw new Error("Invalid raw");
            node.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassAccessorProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators", "typeAnnotation"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name) => {
      defineType(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    var _utils = require_utils();
    var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    exports.PLACEHOLDERS = PLACEHOLDERS;
    var PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length)
        PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = {};
    exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    {
      defineType("Noop", {
        visitor: []
      });
    }
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils();
    var _core = require_core4();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation", "initializer"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "typeAnnotation", "nameType"],
      fields: {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent, key, node) {
              if ((0, _is.default)("UnaryExpression", node)) {
                unaryOperator(node, "operator", node.operator);
                unaryExpression(node, "argument", node.argument);
              } else {
                literal(parent, key, node);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
      }
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      visitor: ["argument", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement"],
      visitor: ["id", "moduleReference"],
      fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
    exports.DEPRECATED_ALIASES = DEPRECATED_ALIASES;
  }
});

// node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/@babel/types/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    var _toFastProperties = require_to_fast_properties();
    require_core4();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
    exports.TYPES = TYPES;
  }
});

// node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "node_modules/@babel/types/lib/validators/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validate;
    exports.validateChild = validateChild;
    exports.validateField = validateField;
    var _definitions = require_definitions();
    function validate(node, key, val) {
      if (!node)
        return;
      const fields = _definitions.NODE_FIELDS[node.type];
      if (!fields)
        return;
      const field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateField(node, key, val, field) {
      if (!(field != null && field.validate))
        return;
      if (field.optional && val == null)
        return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      if (val == null)
        return;
      const validate2 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
      if (!validate2)
        return;
      validate2(node, key, val);
    }
  }
});

// node_modules/@babel/types/lib/builders/validateNode.js
var require_validateNode = __commonJS({
  "node_modules/@babel/types/lib/builders/validateNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validateNode;
    var _validate = require_validate();
    var _ = require_lib5();
    function validateNode(node) {
      const keys = _.BUILDER_KEYS[node.type];
      for (const key of keys) {
        (0, _validate.default)(node, key, node[key]);
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.arrayExpression = arrayExpression;
    exports.arrayPattern = arrayPattern;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.assignmentPattern = assignmentPattern;
    exports.awaitExpression = awaitExpression;
    exports.bigIntLiteral = bigIntLiteral;
    exports.binaryExpression = binaryExpression;
    exports.bindExpression = bindExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.classAccessorProperty = classAccessorProperty;
    exports.classBody = classBody;
    exports.classDeclaration = classDeclaration;
    exports.classExpression = classExpression;
    exports.classImplements = classImplements;
    exports.classMethod = classMethod;
    exports.classPrivateMethod = classPrivateMethod;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classProperty = classProperty;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.decimalLiteral = decimalLiteral;
    exports.declareClass = declareClass;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareVariable = declareVariable;
    exports.declaredPredicate = declaredPredicate;
    exports.decorator = decorator;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.doExpression = doExpression;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumDeclaration = enumDeclaration;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.enumNumberBody = enumNumberBody;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringBody = enumStringBody;
    exports.enumStringMember = enumStringMember;
    exports.enumSymbolBody = enumSymbolBody;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.exportSpecifier = exportSpecifier;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forOfStatement = forOfStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.import = _import;
    exports.importAttribute = importAttribute;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.indexedAccessType = indexedAccessType;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.interpreterDirective = interpreterDirective;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
    exports.jSXElement = exports.jsxElement = jsxElement;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
    exports.jSXFragment = exports.jsxFragment = jsxFragment;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXText = exports.jsxText = jsxText;
    exports.labeledStatement = labeledStatement;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.metaProperty = metaProperty;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.moduleExpression = moduleExpression;
    exports.newExpression = newExpression;
    exports.noop = noop;
    exports.nullLiteral = nullLiteral;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteral = NumberLiteral;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectPattern = objectPattern;
    exports.objectProperty = objectProperty;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.optionalCallExpression = optionalCallExpression;
    exports.optionalIndexedAccessType = optionalIndexedAccessType;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.placeholder = placeholder;
    exports.privateName = privateName;
    exports.program = program;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.recordExpression = recordExpression;
    exports.regExpLiteral = regExpLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restElement = restElement;
    exports.restProperty = RestProperty;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.spreadElement = spreadElement;
    exports.spreadProperty = SpreadProperty;
    exports.staticBlock = staticBlock;
    exports.stringLiteral = stringLiteral;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.super = _super;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.thisExpression = thisExpression;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.throwStatement = throwStatement;
    exports.topicReference = topicReference;
    exports.tryStatement = tryStatement;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tupleExpression = tupleExpression;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.unaryExpression = unaryExpression;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.updateExpression = updateExpression;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.variance = variance;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.yieldExpression = yieldExpression;
    var _validateNode = require_validateNode();
    var _deprecationWarning = require_deprecationWarning();
    function arrayExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "ArrayExpression",
        elements
      });
    }
    function assignmentExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentExpression",
        operator,
        left,
        right
      });
    }
    function binaryExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "BinaryExpression",
        operator,
        left,
        right
      });
    }
    function interpreterDirective(value) {
      return (0, _validateNode.default)({
        type: "InterpreterDirective",
        value
      });
    }
    function directive(value) {
      return (0, _validateNode.default)({
        type: "Directive",
        value
      });
    }
    function directiveLiteral(value) {
      return (0, _validateNode.default)({
        type: "DirectiveLiteral",
        value
      });
    }
    function blockStatement(body, directives = []) {
      return (0, _validateNode.default)({
        type: "BlockStatement",
        body,
        directives
      });
    }
    function breakStatement(label = null) {
      return (0, _validateNode.default)({
        type: "BreakStatement",
        label
      });
    }
    function callExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "CallExpression",
        callee,
        arguments: _arguments
      });
    }
    function catchClause(param = null, body) {
      return (0, _validateNode.default)({
        type: "CatchClause",
        param,
        body
      });
    }
    function conditionalExpression(test, consequent, alternate) {
      return (0, _validateNode.default)({
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      });
    }
    function continueStatement(label = null) {
      return (0, _validateNode.default)({
        type: "ContinueStatement",
        label
      });
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      return (0, _validateNode.default)({
        type: "DoWhileStatement",
        test,
        body
      });
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      return (0, _validateNode.default)({
        type: "ExpressionStatement",
        expression
      });
    }
    function file(program2, comments = null, tokens = null) {
      return (0, _validateNode.default)({
        type: "File",
        program: program2,
        comments,
        tokens
      });
    }
    function forInStatement(left, right, body) {
      return (0, _validateNode.default)({
        type: "ForInStatement",
        left,
        right,
        body
      });
    }
    function forStatement(init = null, test = null, update = null, body) {
      return (0, _validateNode.default)({
        type: "ForStatement",
        init,
        test,
        update,
        body
      });
    }
    function functionDeclaration(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function functionExpression(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function identifier(name) {
      return (0, _validateNode.default)({
        type: "Identifier",
        name
      });
    }
    function ifStatement(test, consequent, alternate = null) {
      return (0, _validateNode.default)({
        type: "IfStatement",
        test,
        consequent,
        alternate
      });
    }
    function labeledStatement(label, body) {
      return (0, _validateNode.default)({
        type: "LabeledStatement",
        label,
        body
      });
    }
    function stringLiteral(value) {
      return (0, _validateNode.default)({
        type: "StringLiteral",
        value
      });
    }
    function numericLiteral(value) {
      return (0, _validateNode.default)({
        type: "NumericLiteral",
        value
      });
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value) {
      return (0, _validateNode.default)({
        type: "BooleanLiteral",
        value
      });
    }
    function regExpLiteral(pattern, flags = "") {
      return (0, _validateNode.default)({
        type: "RegExpLiteral",
        pattern,
        flags
      });
    }
    function logicalExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "LogicalExpression",
        operator,
        left,
        right
      });
    }
    function memberExpression(object, property, computed = false, optional = null) {
      return (0, _validateNode.default)({
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function newExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "NewExpression",
        callee,
        arguments: _arguments
      });
    }
    function program(body, directives = [], sourceType = "script", interpreter = null) {
      return (0, _validateNode.default)({
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter,
        sourceFile: null
      });
    }
    function objectExpression(properties) {
      return (0, _validateNode.default)({
        type: "ObjectExpression",
        properties
      });
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      });
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      return (0, _validateNode.default)({
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      });
    }
    function restElement(argument) {
      return (0, _validateNode.default)({
        type: "RestElement",
        argument
      });
    }
    function returnStatement(argument = null) {
      return (0, _validateNode.default)({
        type: "ReturnStatement",
        argument
      });
    }
    function sequenceExpression(expressions) {
      return (0, _validateNode.default)({
        type: "SequenceExpression",
        expressions
      });
    }
    function parenthesizedExpression(expression) {
      return (0, _validateNode.default)({
        type: "ParenthesizedExpression",
        expression
      });
    }
    function switchCase(test = null, consequent) {
      return (0, _validateNode.default)({
        type: "SwitchCase",
        test,
        consequent
      });
    }
    function switchStatement(discriminant, cases) {
      return (0, _validateNode.default)({
        type: "SwitchStatement",
        discriminant,
        cases
      });
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      return (0, _validateNode.default)({
        type: "ThrowStatement",
        argument
      });
    }
    function tryStatement(block, handler = null, finalizer = null) {
      return (0, _validateNode.default)({
        type: "TryStatement",
        block,
        handler,
        finalizer
      });
    }
    function unaryExpression(operator, argument, prefix = true) {
      return (0, _validateNode.default)({
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      });
    }
    function updateExpression(operator, argument, prefix = false) {
      return (0, _validateNode.default)({
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      });
    }
    function variableDeclaration(kind, declarations) {
      return (0, _validateNode.default)({
        type: "VariableDeclaration",
        kind,
        declarations
      });
    }
    function variableDeclarator(id, init = null) {
      return (0, _validateNode.default)({
        type: "VariableDeclarator",
        id,
        init
      });
    }
    function whileStatement(test, body) {
      return (0, _validateNode.default)({
        type: "WhileStatement",
        test,
        body
      });
    }
    function withStatement(object, body) {
      return (0, _validateNode.default)({
        type: "WithStatement",
        object,
        body
      });
    }
    function assignmentPattern(left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentPattern",
        left,
        right
      });
    }
    function arrayPattern(elements) {
      return (0, _validateNode.default)({
        type: "ArrayPattern",
        elements
      });
    }
    function arrowFunctionExpression(params, body, async = false) {
      return (0, _validateNode.default)({
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      });
    }
    function classBody(body) {
      return (0, _validateNode.default)({
        type: "ClassBody",
        body
      });
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      });
    }
    function classDeclaration(id, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      });
    }
    function exportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "ExportAllDeclaration",
        source
      });
    }
    function exportDefaultDeclaration(declaration) {
      return (0, _validateNode.default)({
        type: "ExportDefaultDeclaration",
        declaration
      });
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      return (0, _validateNode.default)({
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function exportSpecifier(local, exported) {
      return (0, _validateNode.default)({
        type: "ExportSpecifier",
        local,
        exported
      });
    }
    function forOfStatement(left, right, body, _await = false) {
      return (0, _validateNode.default)({
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      });
    }
    function importDeclaration(specifiers, source) {
      return (0, _validateNode.default)({
        type: "ImportDeclaration",
        specifiers,
        source
      });
    }
    function importDefaultSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportDefaultSpecifier",
        local
      });
    }
    function importNamespaceSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportNamespaceSpecifier",
        local
      });
    }
    function importSpecifier(local, imported) {
      return (0, _validateNode.default)({
        type: "ImportSpecifier",
        local,
        imported
      });
    }
    function metaProperty(meta, property) {
      return (0, _validateNode.default)({
        type: "MetaProperty",
        meta,
        property
      });
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      });
    }
    function objectPattern(properties) {
      return (0, _validateNode.default)({
        type: "ObjectPattern",
        properties
      });
    }
    function spreadElement(argument) {
      return (0, _validateNode.default)({
        type: "SpreadElement",
        argument
      });
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      return (0, _validateNode.default)({
        type: "TaggedTemplateExpression",
        tag,
        quasi
      });
    }
    function templateElement(value, tail = false) {
      return (0, _validateNode.default)({
        type: "TemplateElement",
        value,
        tail
      });
    }
    function templateLiteral(quasis, expressions) {
      return (0, _validateNode.default)({
        type: "TemplateLiteral",
        quasis,
        expressions
      });
    }
    function yieldExpression(argument = null, delegate = false) {
      return (0, _validateNode.default)({
        type: "YieldExpression",
        argument,
        delegate
      });
    }
    function awaitExpression(argument) {
      return (0, _validateNode.default)({
        type: "AwaitExpression",
        argument
      });
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value) {
      return (0, _validateNode.default)({
        type: "BigIntLiteral",
        value
      });
    }
    function exportNamespaceSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportNamespaceSpecifier",
        exported
      });
    }
    function optionalMemberExpression(object, property, computed = false, optional) {
      return (0, _validateNode.default)({
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function optionalCallExpression(callee, _arguments, optional) {
      return (0, _validateNode.default)({
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      });
    }
    function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassAccessorProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classPrivateProperty(key, value = null, decorators = null, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateProperty",
        key,
        value,
        decorators,
        static: _static
      });
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      });
    }
    function privateName(id) {
      return (0, _validateNode.default)({
        type: "PrivateName",
        id
      });
    }
    function staticBlock(body) {
      return (0, _validateNode.default)({
        type: "StaticBlock",
        body
      });
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      return (0, _validateNode.default)({
        type: "ArrayTypeAnnotation",
        elementType
      });
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "BooleanLiteralTypeAnnotation",
        value
      });
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "ClassImplements",
        id,
        typeParameters
      });
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareFunction(id) {
      return (0, _validateNode.default)({
        type: "DeclareFunction",
        id
      });
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareModule(id, body, kind = null) {
      return (0, _validateNode.default)({
        type: "DeclareModule",
        id,
        body,
        kind
      });
    }
    function declareModuleExports(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      });
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      return (0, _validateNode.default)({
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      });
    }
    function declareVariable(id) {
      return (0, _validateNode.default)({
        type: "DeclareVariable",
        id
      });
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
      return (0, _validateNode.default)({
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function declareExportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "DeclareExportAllDeclaration",
        source
      });
    }
    function declaredPredicate(value) {
      return (0, _validateNode.default)({
        type: "DeclaredPredicate",
        value
      });
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      return (0, _validateNode.default)({
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      });
    }
    function functionTypeParam(name = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "FunctionTypeParam",
        name,
        typeAnnotation: typeAnnotation2
      });
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      });
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "InterfaceExtends",
        id,
        typeParameters
      });
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      });
    }
    function intersectionTypeAnnotation(types) {
      return (0, _validateNode.default)({
        type: "IntersectionTypeAnnotation",
        types
      });
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function numberLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "NumberLiteralTypeAnnotation",
        value
      });
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      return (0, _validateNode.default)({
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      });
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      return (0, _validateNode.default)({
        type: "ObjectTypeInternalSlot",
        id,
        value,
        optional,
        static: _static,
        method
      });
    }
    function objectTypeCallProperty(value) {
      return (0, _validateNode.default)({
        type: "ObjectTypeCallProperty",
        value,
        static: null
      });
    }
    function objectTypeIndexer(id = null, key, value, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeIndexer",
        id,
        key,
        value,
        variance: variance2,
        static: null
      });
    }
    function objectTypeProperty(key, value, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeProperty",
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      });
    }
    function objectTypeSpreadProperty(argument) {
      return (0, _validateNode.default)({
        type: "ObjectTypeSpreadProperty",
        argument
      });
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      return (0, _validateNode.default)({
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      });
    }
    function qualifiedTypeIdentifier(id, qualification) {
      return (0, _validateNode.default)({
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      });
    }
    function stringLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "StringLiteralTypeAnnotation",
        value
      });
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types) {
      return (0, _validateNode.default)({
        type: "TupleTypeAnnotation",
        types
      });
    }
    function typeofTypeAnnotation(argument) {
      return (0, _validateNode.default)({
        type: "TypeofTypeAnnotation",
        argument
      });
    }
    function typeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "TypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function typeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function typeCastExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      return (0, _validateNode.default)({
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      });
    }
    function typeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterDeclaration",
        params
      });
    }
    function typeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterInstantiation",
        params
      });
    }
    function unionTypeAnnotation(types) {
      return (0, _validateNode.default)({
        type: "UnionTypeAnnotation",
        types
      });
    }
    function variance(kind) {
      return (0, _validateNode.default)({
        type: "Variance",
        kind
      });
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "EnumDeclaration",
        id,
        body
      });
    }
    function enumBooleanBody(members) {
      return (0, _validateNode.default)({
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumNumberBody(members) {
      return (0, _validateNode.default)({
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumStringBody(members) {
      return (0, _validateNode.default)({
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumSymbolBody(members) {
      return (0, _validateNode.default)({
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      });
    }
    function enumBooleanMember(id) {
      return (0, _validateNode.default)({
        type: "EnumBooleanMember",
        id,
        init: null
      });
    }
    function enumNumberMember(id, init) {
      return (0, _validateNode.default)({
        type: "EnumNumberMember",
        id,
        init
      });
    }
    function enumStringMember(id, init) {
      return (0, _validateNode.default)({
        type: "EnumStringMember",
        id,
        init
      });
    }
    function enumDefaultedMember(id) {
      return (0, _validateNode.default)({
        type: "EnumDefaultedMember",
        id
      });
    }
    function indexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "IndexedAccessType",
        objectType,
        indexType
      });
    }
    function optionalIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      });
    }
    function jsxAttribute(name, value = null) {
      return (0, _validateNode.default)({
        type: "JSXAttribute",
        name,
        value
      });
    }
    function jsxClosingElement(name) {
      return (0, _validateNode.default)({
        type: "JSXClosingElement",
        name
      });
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      return (0, _validateNode.default)({
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      });
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      return (0, _validateNode.default)({
        type: "JSXExpressionContainer",
        expression
      });
    }
    function jsxSpreadChild(expression) {
      return (0, _validateNode.default)({
        type: "JSXSpreadChild",
        expression
      });
    }
    function jsxIdentifier(name) {
      return (0, _validateNode.default)({
        type: "JSXIdentifier",
        name
      });
    }
    function jsxMemberExpression(object, property) {
      return (0, _validateNode.default)({
        type: "JSXMemberExpression",
        object,
        property
      });
    }
    function jsxNamespacedName(namespace, name) {
      return (0, _validateNode.default)({
        type: "JSXNamespacedName",
        namespace,
        name
      });
    }
    function jsxOpeningElement(name, attributes, selfClosing = false) {
      return (0, _validateNode.default)({
        type: "JSXOpeningElement",
        name,
        attributes,
        selfClosing
      });
    }
    function jsxSpreadAttribute(argument) {
      return (0, _validateNode.default)({
        type: "JSXSpreadAttribute",
        argument
      });
    }
    function jsxText(value) {
      return (0, _validateNode.default)({
        type: "JSXText",
        value
      });
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      return (0, _validateNode.default)({
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      });
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name) {
      return (0, _validateNode.default)({
        type: "Placeholder",
        expectedNode,
        name
      });
    }
    function v8IntrinsicIdentifier(name) {
      return (0, _validateNode.default)({
        type: "V8IntrinsicIdentifier",
        name
      });
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      return (0, _validateNode.default)({
        type: "BindExpression",
        object,
        callee
      });
    }
    function importAttribute(key, value) {
      return (0, _validateNode.default)({
        type: "ImportAttribute",
        key,
        value
      });
    }
    function decorator(expression) {
      return (0, _validateNode.default)({
        type: "Decorator",
        expression
      });
    }
    function doExpression(body, async = false) {
      return (0, _validateNode.default)({
        type: "DoExpression",
        body,
        async
      });
    }
    function exportDefaultSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportDefaultSpecifier",
        exported
      });
    }
    function recordExpression(properties) {
      return (0, _validateNode.default)({
        type: "RecordExpression",
        properties
      });
    }
    function tupleExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "TupleExpression",
        elements
      });
    }
    function decimalLiteral(value) {
      return (0, _validateNode.default)({
        type: "DecimalLiteral",
        value
      });
    }
    function moduleExpression(body) {
      return (0, _validateNode.default)({
        type: "ModuleExpression",
        body
      });
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      return (0, _validateNode.default)({
        type: "PipelineTopicExpression",
        expression
      });
    }
    function pipelineBareFunction(callee) {
      return (0, _validateNode.default)({
        type: "PipelineBareFunction",
        callee
      });
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      return (0, _validateNode.default)({
        type: "TSParameterProperty",
        parameter
      });
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      });
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      });
    }
    function tsQualifiedName(left, right) {
      return (0, _validateNode.default)({
        type: "TSQualifiedName",
        left,
        right
      });
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsPropertySignature(key, typeAnnotation2 = null, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2,
        initializer,
        kind: null
      });
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeReference(typeName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeReference",
        typeName,
        typeParameters
      });
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      return (0, _validateNode.default)({
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      });
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeQuery",
        exprName,
        typeParameters
      });
    }
    function tsTypeLiteral(members) {
      return (0, _validateNode.default)({
        type: "TSTypeLiteral",
        members
      });
    }
    function tsArrayType(elementType) {
      return (0, _validateNode.default)({
        type: "TSArrayType",
        elementType
      });
    }
    function tsTupleType(elementTypes) {
      return (0, _validateNode.default)({
        type: "TSTupleType",
        elementTypes
      });
    }
    function tsOptionalType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsRestType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      return (0, _validateNode.default)({
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      });
    }
    function tsUnionType(types) {
      return (0, _validateNode.default)({
        type: "TSUnionType",
        types
      });
    }
    function tsIntersectionType(types) {
      return (0, _validateNode.default)({
        type: "TSIntersectionType",
        types
      });
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return (0, _validateNode.default)({
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      });
    }
    function tsInferType(typeParameter2) {
      return (0, _validateNode.default)({
        type: "TSInferType",
        typeParameter: typeParameter2
      });
    }
    function tsParenthesizedType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeOperator(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      });
    }
    function tsIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "TSIndexedAccessType",
        objectType,
        indexType
      });
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      return (0, _validateNode.default)({
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      });
    }
    function tsLiteralType(literal) {
      return (0, _validateNode.default)({
        type: "TSLiteralType",
        literal
      });
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      });
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function tsInterfaceBody(body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceBody",
        body
      });
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      });
    }
    function tsAsExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      return (0, _validateNode.default)({
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      });
    }
    function tsEnumDeclaration(id, members) {
      return (0, _validateNode.default)({
        type: "TSEnumDeclaration",
        id,
        members
      });
    }
    function tsEnumMember(id, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSEnumMember",
        id,
        initializer
      });
    }
    function tsModuleDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "TSModuleDeclaration",
        id,
        body
      });
    }
    function tsModuleBlock(body) {
      return (0, _validateNode.default)({
        type: "TSModuleBlock",
        body
      });
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      });
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      return (0, _validateNode.default)({
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      });
    }
    function tsExternalModuleReference(expression) {
      return (0, _validateNode.default)({
        type: "TSExternalModuleReference",
        expression
      });
    }
    function tsNonNullExpression(expression) {
      return (0, _validateNode.default)({
        type: "TSNonNullExpression",
        expression
      });
    }
    function tsExportAssignment(expression) {
      return (0, _validateNode.default)({
        type: "TSExportAssignment",
        expression
      });
    }
    function tsNamespaceExportDeclaration(id) {
      return (0, _validateNode.default)({
        type: "TSNamespaceExportDeclaration",
        id
      });
    }
    function tsTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterInstantiation",
        params
      });
    }
    function tsTypeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterDeclaration",
        params
      });
    }
    function tsTypeParameter(constraint = null, _default = null, name) {
      return (0, _validateNode.default)({
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name
      });
    }
    function NumberLiteral(value) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value);
    }
    function RegexLiteral(pattern, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cleanJSXElementLiteralChild;
    var _generated = require_generated2();
    var _ = require_lib5();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push((0, _.inherits)((0, _generated.stringLiteral)(str), child));
    }
  }
});

// node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildChildren;
    var _generated = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      const elements = [];
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        if ((0, _generated.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child))
          child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child))
          continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "node_modules/@babel/types/lib/validators/isNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNode;
    var _definitions = require_definitions();
    function isNode(node) {
      return !!(node && _definitions.VISITOR_KEYS[node.type]);
    }
  }
});

// node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertAccessor = assertAccessor;
    exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports.assertArrayExpression = assertArrayExpression;
    exports.assertArrayPattern = assertArrayPattern;
    exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports.assertAssignmentExpression = assertAssignmentExpression;
    exports.assertAssignmentPattern = assertAssignmentPattern;
    exports.assertAwaitExpression = assertAwaitExpression;
    exports.assertBigIntLiteral = assertBigIntLiteral;
    exports.assertBinary = assertBinary;
    exports.assertBinaryExpression = assertBinaryExpression;
    exports.assertBindExpression = assertBindExpression;
    exports.assertBlock = assertBlock;
    exports.assertBlockParent = assertBlockParent;
    exports.assertBlockStatement = assertBlockStatement;
    exports.assertBooleanLiteral = assertBooleanLiteral;
    exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports.assertBreakStatement = assertBreakStatement;
    exports.assertCallExpression = assertCallExpression;
    exports.assertCatchClause = assertCatchClause;
    exports.assertClass = assertClass;
    exports.assertClassAccessorProperty = assertClassAccessorProperty;
    exports.assertClassBody = assertClassBody;
    exports.assertClassDeclaration = assertClassDeclaration;
    exports.assertClassExpression = assertClassExpression;
    exports.assertClassImplements = assertClassImplements;
    exports.assertClassMethod = assertClassMethod;
    exports.assertClassPrivateMethod = assertClassPrivateMethod;
    exports.assertClassPrivateProperty = assertClassPrivateProperty;
    exports.assertClassProperty = assertClassProperty;
    exports.assertCompletionStatement = assertCompletionStatement;
    exports.assertConditional = assertConditional;
    exports.assertConditionalExpression = assertConditionalExpression;
    exports.assertContinueStatement = assertContinueStatement;
    exports.assertDebuggerStatement = assertDebuggerStatement;
    exports.assertDecimalLiteral = assertDecimalLiteral;
    exports.assertDeclaration = assertDeclaration;
    exports.assertDeclareClass = assertDeclareClass;
    exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports.assertDeclareFunction = assertDeclareFunction;
    exports.assertDeclareInterface = assertDeclareInterface;
    exports.assertDeclareModule = assertDeclareModule;
    exports.assertDeclareModuleExports = assertDeclareModuleExports;
    exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports.assertDeclareVariable = assertDeclareVariable;
    exports.assertDeclaredPredicate = assertDeclaredPredicate;
    exports.assertDecorator = assertDecorator;
    exports.assertDirective = assertDirective;
    exports.assertDirectiveLiteral = assertDirectiveLiteral;
    exports.assertDoExpression = assertDoExpression;
    exports.assertDoWhileStatement = assertDoWhileStatement;
    exports.assertEmptyStatement = assertEmptyStatement;
    exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports.assertEnumBody = assertEnumBody;
    exports.assertEnumBooleanBody = assertEnumBooleanBody;
    exports.assertEnumBooleanMember = assertEnumBooleanMember;
    exports.assertEnumDeclaration = assertEnumDeclaration;
    exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports.assertEnumMember = assertEnumMember;
    exports.assertEnumNumberBody = assertEnumNumberBody;
    exports.assertEnumNumberMember = assertEnumNumberMember;
    exports.assertEnumStringBody = assertEnumStringBody;
    exports.assertEnumStringMember = assertEnumStringMember;
    exports.assertEnumSymbolBody = assertEnumSymbolBody;
    exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports.assertExportAllDeclaration = assertExportAllDeclaration;
    exports.assertExportDeclaration = assertExportDeclaration;
    exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports.assertExportSpecifier = assertExportSpecifier;
    exports.assertExpression = assertExpression;
    exports.assertExpressionStatement = assertExpressionStatement;
    exports.assertExpressionWrapper = assertExpressionWrapper;
    exports.assertFile = assertFile;
    exports.assertFlow = assertFlow;
    exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports.assertFlowDeclaration = assertFlowDeclaration;
    exports.assertFlowPredicate = assertFlowPredicate;
    exports.assertFlowType = assertFlowType;
    exports.assertFor = assertFor;
    exports.assertForInStatement = assertForInStatement;
    exports.assertForOfStatement = assertForOfStatement;
    exports.assertForStatement = assertForStatement;
    exports.assertForXStatement = assertForXStatement;
    exports.assertFunction = assertFunction;
    exports.assertFunctionDeclaration = assertFunctionDeclaration;
    exports.assertFunctionExpression = assertFunctionExpression;
    exports.assertFunctionParent = assertFunctionParent;
    exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports.assertFunctionTypeParam = assertFunctionTypeParam;
    exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports.assertIdentifier = assertIdentifier;
    exports.assertIfStatement = assertIfStatement;
    exports.assertImmutable = assertImmutable;
    exports.assertImport = assertImport;
    exports.assertImportAttribute = assertImportAttribute;
    exports.assertImportDeclaration = assertImportDeclaration;
    exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports.assertImportSpecifier = assertImportSpecifier;
    exports.assertIndexedAccessType = assertIndexedAccessType;
    exports.assertInferredPredicate = assertInferredPredicate;
    exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports.assertInterfaceExtends = assertInterfaceExtends;
    exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports.assertInterpreterDirective = assertInterpreterDirective;
    exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports.assertJSX = assertJSX;
    exports.assertJSXAttribute = assertJSXAttribute;
    exports.assertJSXClosingElement = assertJSXClosingElement;
    exports.assertJSXClosingFragment = assertJSXClosingFragment;
    exports.assertJSXElement = assertJSXElement;
    exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports.assertJSXFragment = assertJSXFragment;
    exports.assertJSXIdentifier = assertJSXIdentifier;
    exports.assertJSXMemberExpression = assertJSXMemberExpression;
    exports.assertJSXNamespacedName = assertJSXNamespacedName;
    exports.assertJSXOpeningElement = assertJSXOpeningElement;
    exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports.assertJSXSpreadChild = assertJSXSpreadChild;
    exports.assertJSXText = assertJSXText;
    exports.assertLVal = assertLVal;
    exports.assertLabeledStatement = assertLabeledStatement;
    exports.assertLiteral = assertLiteral;
    exports.assertLogicalExpression = assertLogicalExpression;
    exports.assertLoop = assertLoop;
    exports.assertMemberExpression = assertMemberExpression;
    exports.assertMetaProperty = assertMetaProperty;
    exports.assertMethod = assertMethod;
    exports.assertMiscellaneous = assertMiscellaneous;
    exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports.assertModuleDeclaration = assertModuleDeclaration;
    exports.assertModuleExpression = assertModuleExpression;
    exports.assertModuleSpecifier = assertModuleSpecifier;
    exports.assertNewExpression = assertNewExpression;
    exports.assertNoop = assertNoop;
    exports.assertNullLiteral = assertNullLiteral;
    exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports.assertNumberLiteral = assertNumberLiteral;
    exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports.assertNumericLiteral = assertNumericLiteral;
    exports.assertObjectExpression = assertObjectExpression;
    exports.assertObjectMember = assertObjectMember;
    exports.assertObjectMethod = assertObjectMethod;
    exports.assertObjectPattern = assertObjectPattern;
    exports.assertObjectProperty = assertObjectProperty;
    exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports.assertObjectTypeProperty = assertObjectTypeProperty;
    exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports.assertOpaqueType = assertOpaqueType;
    exports.assertOptionalCallExpression = assertOptionalCallExpression;
    exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports.assertParenthesizedExpression = assertParenthesizedExpression;
    exports.assertPattern = assertPattern;
    exports.assertPatternLike = assertPatternLike;
    exports.assertPipelineBareFunction = assertPipelineBareFunction;
    exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports.assertPlaceholder = assertPlaceholder;
    exports.assertPrivate = assertPrivate;
    exports.assertPrivateName = assertPrivateName;
    exports.assertProgram = assertProgram;
    exports.assertProperty = assertProperty;
    exports.assertPureish = assertPureish;
    exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports.assertRecordExpression = assertRecordExpression;
    exports.assertRegExpLiteral = assertRegExpLiteral;
    exports.assertRegexLiteral = assertRegexLiteral;
    exports.assertRestElement = assertRestElement;
    exports.assertRestProperty = assertRestProperty;
    exports.assertReturnStatement = assertReturnStatement;
    exports.assertScopable = assertScopable;
    exports.assertSequenceExpression = assertSequenceExpression;
    exports.assertSpreadElement = assertSpreadElement;
    exports.assertSpreadProperty = assertSpreadProperty;
    exports.assertStandardized = assertStandardized;
    exports.assertStatement = assertStatement;
    exports.assertStaticBlock = assertStaticBlock;
    exports.assertStringLiteral = assertStringLiteral;
    exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports.assertSuper = assertSuper;
    exports.assertSwitchCase = assertSwitchCase;
    exports.assertSwitchStatement = assertSwitchStatement;
    exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports.assertTSAnyKeyword = assertTSAnyKeyword;
    exports.assertTSArrayType = assertTSArrayType;
    exports.assertTSAsExpression = assertTSAsExpression;
    exports.assertTSBaseType = assertTSBaseType;
    exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports.assertTSConditionalType = assertTSConditionalType;
    exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports.assertTSConstructorType = assertTSConstructorType;
    exports.assertTSDeclareFunction = assertTSDeclareFunction;
    exports.assertTSDeclareMethod = assertTSDeclareMethod;
    exports.assertTSEntityName = assertTSEntityName;
    exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports.assertTSEnumMember = assertTSEnumMember;
    exports.assertTSExportAssignment = assertTSExportAssignment;
    exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports.assertTSFunctionType = assertTSFunctionType;
    exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports.assertTSImportType = assertTSImportType;
    exports.assertTSIndexSignature = assertTSIndexSignature;
    exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports.assertTSInferType = assertTSInferType;
    exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports.assertTSInterfaceBody = assertTSInterfaceBody;
    exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports.assertTSIntersectionType = assertTSIntersectionType;
    exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports.assertTSLiteralType = assertTSLiteralType;
    exports.assertTSMappedType = assertTSMappedType;
    exports.assertTSMethodSignature = assertTSMethodSignature;
    exports.assertTSModuleBlock = assertTSModuleBlock;
    exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports.assertTSNeverKeyword = assertTSNeverKeyword;
    exports.assertTSNonNullExpression = assertTSNonNullExpression;
    exports.assertTSNullKeyword = assertTSNullKeyword;
    exports.assertTSNumberKeyword = assertTSNumberKeyword;
    exports.assertTSObjectKeyword = assertTSObjectKeyword;
    exports.assertTSOptionalType = assertTSOptionalType;
    exports.assertTSParameterProperty = assertTSParameterProperty;
    exports.assertTSParenthesizedType = assertTSParenthesizedType;
    exports.assertTSPropertySignature = assertTSPropertySignature;
    exports.assertTSQualifiedName = assertTSQualifiedName;
    exports.assertTSRestType = assertTSRestType;
    exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports.assertTSStringKeyword = assertTSStringKeyword;
    exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports.assertTSThisType = assertTSThisType;
    exports.assertTSTupleType = assertTSTupleType;
    exports.assertTSType = assertTSType;
    exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports.assertTSTypeAssertion = assertTSTypeAssertion;
    exports.assertTSTypeElement = assertTSTypeElement;
    exports.assertTSTypeLiteral = assertTSTypeLiteral;
    exports.assertTSTypeOperator = assertTSTypeOperator;
    exports.assertTSTypeParameter = assertTSTypeParameter;
    exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports.assertTSTypePredicate = assertTSTypePredicate;
    exports.assertTSTypeQuery = assertTSTypeQuery;
    exports.assertTSTypeReference = assertTSTypeReference;
    exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports.assertTSUnionType = assertTSUnionType;
    exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports.assertTSVoidKeyword = assertTSVoidKeyword;
    exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports.assertTemplateElement = assertTemplateElement;
    exports.assertTemplateLiteral = assertTemplateLiteral;
    exports.assertTerminatorless = assertTerminatorless;
    exports.assertThisExpression = assertThisExpression;
    exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports.assertThrowStatement = assertThrowStatement;
    exports.assertTopicReference = assertTopicReference;
    exports.assertTryStatement = assertTryStatement;
    exports.assertTupleExpression = assertTupleExpression;
    exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports.assertTypeAlias = assertTypeAlias;
    exports.assertTypeAnnotation = assertTypeAnnotation;
    exports.assertTypeCastExpression = assertTypeCastExpression;
    exports.assertTypeParameter = assertTypeParameter;
    exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports.assertTypeScript = assertTypeScript;
    exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports.assertUnaryExpression = assertUnaryExpression;
    exports.assertUnaryLike = assertUnaryLike;
    exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports.assertUpdateExpression = assertUpdateExpression;
    exports.assertUserWhitespacable = assertUserWhitespacable;
    exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports.assertVariableDeclaration = assertVariableDeclaration;
    exports.assertVariableDeclarator = assertVariableDeclarator;
    exports.assertVariance = assertVariance;
    exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports.assertWhile = assertWhile;
    exports.assertWhileStatement = assertWhileStatement;
    exports.assertWithStatement = assertWithStatement;
    exports.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert(type, node, opts) {
      if (!(0, _is.default)(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node, opts);
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _generated = require_generated2();
    var _default = createTypeAnnotationBasedOnTypeof;
    exports.default = _default;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _generated.stringTypeAnnotation)();
        case "number":
          return (0, _generated.numberTypeAnnotation)();
        case "undefined":
          return (0, _generated.voidTypeAnnotation)();
        case "boolean":
          return (0, _generated.booleanTypeAnnotation)();
        case "function":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
        case "object":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
        case "symbol":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
        case "bigint":
          return (0, _generated.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _generated = require_generated();
    function getQualifiedName(node) {
      return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodes) {
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _generated.isAnyTypeAnnotation)(node)) {
          return [node];
        }
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes = nodes.concat(node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
          const name = getQualifiedName(node.id);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createFlowUnionType;
    var _generated = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types) {
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _generated.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _generated = require_generated();
    function getQualifiedName(node) {
      return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
    }
    function removeTypeDuplicates(nodes) {
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _generated.isTSAnyKeyword)(node)) {
          return [node];
        }
        if ((0, _generated.isTSBaseType)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
          const name = getQualifiedName(node.typeName);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createTSUnionType;
    var _generated = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types = typeAnnotations.map((type) => {
        return (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _generated.tsUnionType)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _index.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _index.arrayExpression;
      }
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _index.arrayPattern;
      }
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _index.assignmentExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _index.assignmentPattern;
      }
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _index.awaitExpression;
      }
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _index.bigIntLiteral;
      }
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _index.binaryExpression;
      }
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function() {
        return _index.bindExpression;
      }
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _index.blockStatement;
      }
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteral;
      }
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _index.breakStatement;
      }
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function() {
        return _index.callExpression;
      }
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function() {
        return _index.catchClause;
      }
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return _index.classAccessorProperty;
      }
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function() {
        return _index.classBody;
      }
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _index.classDeclaration;
      }
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _index.classExpression;
      }
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _index.classImplements;
      }
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _index.classMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _index.classPrivateMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _index.classPrivateProperty;
      }
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _index.classProperty;
      }
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _index.conditionalExpression;
      }
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _index.continueStatement;
      }
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _index.debuggerStatement;
      }
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _index.decimalLiteral;
      }
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _index.declareClass;
      }
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.declareFunction;
      }
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _index.declareInterface;
      }
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _index.declareModule;
      }
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _index.declareModuleExports;
      }
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _index.declareOpaqueType;
      }
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _index.declareTypeAlias;
      }
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _index.declareVariable;
      }
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _index.declaredPredicate;
      }
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function() {
        return _index.decorator;
      }
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function() {
        return _index.directive;
      }
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _index.directiveLiteral;
      }
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function() {
        return _index.doExpression;
      }
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _index.doWhileStatement;
      }
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _index.emptyStatement;
      }
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanBody;
      }
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanMember;
      }
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.enumDeclaration;
      }
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _index.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _index.enumNumberBody;
      }
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _index.enumNumberMember;
      }
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _index.enumStringBody;
      }
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _index.enumStringMember;
      }
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _index.enumSymbolBody;
      }
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportSpecifier;
      }
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _index.expressionStatement;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function() {
        return _index.file;
      }
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _index.forInStatement;
      }
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _index.forOfStatement;
      }
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function() {
        return _index.forStatement;
      }
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _index.functionDeclaration;
      }
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.functionExpression;
      }
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _index.functionTypeParam;
      }
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function() {
        return _index.identifier;
      }
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function() {
        return _index.ifStatement;
      }
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function() {
        return _index.import;
      }
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _index.importAttribute;
      }
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.importDeclaration;
      }
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importSpecifier;
      }
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.indexedAccessType;
      }
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _index.inferredPredicate;
      }
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _index.interfaceExtends;
      }
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _index.interpreterDirective;
      }
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxAttribute;
      }
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingElement;
      }
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function() {
        return _index.jsxElement;
      }
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _index.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxFragment;
      }
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _index.jsxIdentifier;
      }
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _index.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function() {
        return _index.jsxText;
      }
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _index.labeledStatement;
      }
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _index.logicalExpression;
      }
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _index.memberExpression;
      }
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _index.metaProperty;
      }
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _index.moduleExpression;
      }
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function() {
        return _index.newExpression;
      }
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function() {
        return _index.noop;
      }
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _index.nullLiteral;
      }
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _index.numberLiteral;
      }
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _index.numericLiteral;
      }
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _index.objectExpression;
      }
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _index.objectMethod;
      }
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _index.objectPattern;
      }
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _index.objectProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _index.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _index.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _index.opaqueType;
      }
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalCallExpression;
      }
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _index.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _index.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _index.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _index.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function() {
        return _index.placeholder;
      }
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function() {
        return _index.privateName;
      }
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function() {
        return _index.program;
      }
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _index.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _index.recordExpression;
      }
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _index.regExpLiteral;
      }
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _index.regexLiteral;
      }
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function() {
        return _index.restElement;
      }
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function() {
        return _index.restProperty;
      }
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _index.returnStatement;
      }
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _index.sequenceExpression;
      }
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _index.spreadElement;
      }
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.spreadProperty;
      }
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _index.staticBlock;
      }
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _index.stringLiteral;
      }
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function() {
        return _index.super;
      }
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _index.switchCase;
      }
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _index.switchStatement;
      }
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _index.tsArrayType;
      }
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _index.tsAsExpression;
      }
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _index.tsConditionalType;
      }
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _index.tsConstructorType;
      }
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _index.tsEnumMember;
      }
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _index.tsExportAssignment;
      }
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _index.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _index.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _index.tsFunctionType;
      }
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function() {
        return _index.tsImportType;
      }
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _index.tsIndexSignature;
      }
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function() {
        return _index.tsInferType;
      }
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return _index.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _index.tsIntersectionType;
      }
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _index.tsLiteralType;
      }
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _index.tsMappedType;
      }
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _index.tsMethodSignature;
      }
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _index.tsModuleBlock;
      }
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _index.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _index.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNullKeyword;
      }
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _index.tsOptionalType;
      }
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _index.tsParameterProperty;
      }
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _index.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _index.tsPropertySignature;
      }
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _index.tsQualifiedName;
      }
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function() {
        return _index.tsRestType;
      }
    });
    Object.defineProperty(exports, "TSSatisfiesExpression", {
      enumerable: true,
      get: function() {
        return _index.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsStringKeyword;
      }
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function() {
        return _index.tsThisType;
      }
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _index.tsTupleType;
      }
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _index.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _index.tsTypeOperator;
      }
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameter;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _index.tsTypePredicate;
      }
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _index.tsTypeQuery;
      }
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _index.tsTypeReference;
      }
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _index.tsUnionType;
      }
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _index.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _index.templateElement;
      }
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _index.templateLiteral;
      }
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _index.thisExpression;
      }
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _index.throwStatement;
      }
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function() {
        return _index.topicReference;
      }
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function() {
        return _index.tryStatement;
      }
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _index.tupleExpression;
      }
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _index.typeAlias;
      }
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _index.typeCastExpression;
      }
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _index.typeParameter;
      }
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _index.unaryExpression;
      }
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _index.updateExpression;
      }
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _index.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _index.variableDeclaration;
      }
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _index.variableDeclarator;
      }
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function() {
        return _index.variance;
      }
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _index.whileStatement;
      }
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function() {
        return _index.withStatement;
      }
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _index.yieldExpression;
      }
    });
    var _index = require_generated2();
  }
});

// node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneNode;
    var _definitions = require_definitions();
    var _generated = require_generated();
    var has = Function.call.bind(Object.prototype.hasOwnProperty);
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node, deep = true, withoutLoc = false) {
      return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
      if (!node)
        return node;
      const {
        type
      } = node;
      const newNode = {
        type: node.type
      };
      if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (has(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
      } else if (!has(_definitions.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
          if (has(node, field)) {
            if (deep) {
              newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (has(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (has(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
      }
      if (has(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map((comment) => {
        const cache = commentsCache.get(comment);
        if (cache)
          return cache;
        const {
          type,
          value,
          loc
        } = comment;
        const ret = {
          type,
          value,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment, ret);
        return ret;
      });
    }
  }
});

// node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "node_modules/@babel/types/lib/clone/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clone;
    var _cloneNode = require_cloneNode();
    function clone(node) {
      return (0, _cloneNode.default)(node, false);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, true, true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, false, true);
    }
  }
});

// node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "node_modules/@babel/types/lib/comments/addComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node)
        return node;
      const key = `${type}Comments`;
      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key].push(...comments);
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "node_modules/@babel/types/lib/comments/addComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComment2;
    var _addComments = require_addComments();
    function addComment2(node, type, content, line) {
      return (0, _addComments.default)(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "node_modules/@babel/types/lib/utils/inherit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeComments;
    var _constants = require_constants();
    function removeComments(node) {
      _constants.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      });
      return node;
    }
  }
});

// node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
    var _definitions = require_definitions();
    var STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
    exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
    var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
    exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
    var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
    exports.BINARY_TYPES = BINARY_TYPES;
    var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
    exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
    var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
    exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
    var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
    exports.BLOCK_TYPES = BLOCK_TYPES;
    var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
    exports.STATEMENT_TYPES = STATEMENT_TYPES;
    var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
    exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
    var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
    var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
    exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
    var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
    exports.LOOP_TYPES = LOOP_TYPES;
    var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
    exports.WHILE_TYPES = WHILE_TYPES;
    var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
    var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
    exports.FOR_TYPES = FOR_TYPES;
    var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
    exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
    var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
    exports.FUNCTION_TYPES = FUNCTION_TYPES;
    var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
    exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
    var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
    exports.PUREISH_TYPES = PUREISH_TYPES;
    var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
    exports.DECLARATION_TYPES = DECLARATION_TYPES;
    var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
    exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
    var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
    exports.LVAL_TYPES = LVAL_TYPES;
    var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
    exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
    var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
    exports.LITERAL_TYPES = LITERAL_TYPES;
    var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
    exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
    var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
    var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
    exports.METHOD_TYPES = METHOD_TYPES;
    var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
    exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
    var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
    exports.PROPERTY_TYPES = PROPERTY_TYPES;
    var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
    exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
    var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
    exports.PATTERN_TYPES = PATTERN_TYPES;
    var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
    exports.CLASS_TYPES = CLASS_TYPES;
    var IMPORTOREXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    exports.IMPORTOREXPORTDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
    var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
    var ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Accessor"];
    exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
    var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
    exports.PRIVATE_TYPES = PRIVATE_TYPES;
    var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
    exports.FLOW_TYPES = FLOW_TYPES;
    var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
    exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
    var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
    var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
    var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
    var ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
    exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
    var ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
    exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
    var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
    exports.JSX_TYPES = JSX_TYPES;
    var MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
    var TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
    exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
    var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
    var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
    exports.TSTYPE_TYPES = TSTYPE_TYPES;
    var TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
    exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
  }
});

// node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBlock;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    function toBlock(node, parent) {
      if ((0, _generated.isBlockStatement)(node)) {
        return node;
      }
      let blockNodes = [];
      if ((0, _generated.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _generated.isStatement)(node)) {
          if ((0, _generated.isFunction)(parent)) {
            node = (0, _generated2.returnStatement)(node);
          } else {
            node = (0, _generated2.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _generated2.blockStatement)(blockNodes);
    }
  }
});

// node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      const result = (0, _toBlock.default)(node[key], node);
      node[key] = result;
      return result;
    }
  }
});

// node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    function toIdentifier(input) {
      input = input + "";
      let name = "";
      for (const c of input) {
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name)) {
        name = `_${name}`;
      }
      return name || "_";
    }
  }
});

// node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name) {
      name = (0, _toIdentifier.default)(name);
      if (name === "eval" || name === "arguments")
        name = "_" + name;
      return name;
    }
  }
});

// node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toComputedKey;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      if (!node.computed && (0, _generated.isIdentifier)(key))
        key = (0, _generated2.stringLiteral)(key.name);
      return key;
    }
  }
});

// node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _generated = require_generated();
    var _default = toExpression;
    exports.default = _default;
    function toExpression(node) {
      if ((0, _generated.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _generated.isExpression)(node)) {
        return node;
      }
      if ((0, _generated.isClass)(node)) {
        node.type = "ClassExpression";
      } else if ((0, _generated.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _generated.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverseFast;
    var _definitions = require_definitions();
    function traverseFast(node, enter, opts) {
      if (!node)
        return;
      const keys = _definitions.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      opts = opts || {};
      enter(node, opts);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (const node2 of subNode) {
            traverseFast(node2, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeProperties;
    var _constants = require_constants();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._constants.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node, opts = {}) {
      const map2 = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map2) {
        if (node[key] != null)
          node[key] = void 0;
      }
      for (const key of Object.keys(node)) {
        if (key[0] === "_" && node[key] != null)
          node[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node);
      for (const sym of symbols) {
        node[sym] = null;
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toKeyAlias;
    var _generated = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _generated.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _generated.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node.computed) {
        alias = `[${alias}]`;
      }
      if (node.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getBindingIdentifiers;
    var _generated = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id)
          continue;
        const keys = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
          if ((0, _generated.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _generated.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _generated.isFunctionExpression)(id)) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const nodes = id[key];
            if (nodes) {
              Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
            }
          }
        }
      }
      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
  }
});

// node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _generated = require_generated();
    var _generated2 = require_generated2();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, scope, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!(0, _generated.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _generated.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _generated.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _generated.isVariableDeclaration)(node)) {
          if (node.kind !== "var")
            return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return;
          exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body)
            return;
          exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _generated2.sequenceExpression)(exprs);
      }
    }
  }
});

// node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length))
        return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
      if (!result)
        return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    var _default = toStatement;
    exports.default = _default;
    function toStatement(node, ignore) {
      if ((0, _generated.isStatement)(node)) {
        return node;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _generated.isAssignmentExpression)(node)) {
        return (0, _generated2.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }
      node.type = newType;
      return node;
    }
  }
});

// node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _generated = require_generated2();
    var _default = valueToNode;
    exports.default = _default;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === void 0) {
        return (0, _generated.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _generated.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _generated.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _generated.stringLiteral)(value);
      }
      if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) {
          result = (0, _generated.numericLiteral)(Math.abs(value));
        } else {
          let numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _generated.numericLiteral)(0);
          } else {
            numerator = (0, _generated.numericLiteral)(1);
          }
          result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _generated.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _generated.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _generated.identifier)(key);
          } else {
            nodeKey = (0, _generated.stringLiteral)(key);
          }
          props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = appendToMemberExpression;
    var _generated = require_generated2();
    function appendToMemberExpression(member, append, computed = false) {
      member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
  }
});

// node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherits;
    var _constants = require_constants();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent)
        return child;
      for (const key of _constants.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key[0] === "_" && key !== "__clone") {
          child[key] = parent[key];
        }
      }
      for (const key of _constants.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prependToMemberExpression;
    var _generated = require_generated2();
    var _ = require_lib5();
    function prependToMemberExpression(member, prepend) {
      if ((0, _.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _generated.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = getOuterBindingIdentifiers;
    exports.default = _default;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverse;
    var _definitions = require_definitions();
    function traverse(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys = _definitions.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      if (enter)
        enter(node, ancestors, state);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child)
              continue;
            ancestors.push({
              node,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit)
        exit(node, ancestors, state);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys = _getBindingIdentifiers.default.keys[parent.type];
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0)
              return true;
          } else {
            if (val === node)
              return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "node_modules/@babel/types/lib/validators/isLet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLet;
    var _generated = require_generated();
    var _constants = require_constants();
    function isLet(node) {
      return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBlockScoped;
    var _generated = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isImmutable;
    var _isType = require_isType();
    var _generated = require_generated();
    function isImmutable(node) {
      if ((0, _isType.default)(node.type, "Immutable"))
        return true;
      if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNodesEquivalent;
    var _definitions = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _definitions.VISITOR_KEYS[a.type];
      for (const field of fields) {
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "node_modules/@babel/types/lib/validators/isScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isScope;
    var _generated = require_generated();
    function isScope(node, parent) {
      if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
        return true;
      }
      return (0, _generated.isScopable)(node);
    }
  }
});

// node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSpecifierDefault;
    var _generated = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }
  }
});

// node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "node_modules/@babel/types/lib/validators/isVar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVar;
    var _generated = require_generated();
    var _constants = require_constants();
    function isVar(node) {
      return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// node_modules/@babel/types/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/types/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits2.default;
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports, "toSequenceExpression", {
      enumerable: true,
      get: function() {
        return _toSequenceExpression.default;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _generated = require_generated3();
    Object.keys(_generated).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _generated2 = require_generated2();
    Object.keys(_generated2).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated2[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated2[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _uppercase[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _generated3 = require_generated4();
    Object.keys(_generated3).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated3[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated3[key];
        }
      });
    });
    var _constants = require_constants();
    Object.keys(_constants).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _constants[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _constants[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toSequenceExpression = require_toSequenceExpression();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _definitions = require_definitions();
    Object.keys(_definitions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _definitions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _definitions[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits2 = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _traverse[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _generated4 = require_generated();
    Object.keys(_generated4).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated4[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated4[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    exports.react = react;
  }
});

// node_modules/@babel/helper-module-imports/lib/import-builder.js
var require_import_builder = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/import-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _assert = require_assert();
    var _t = require_lib5();
    var {
      callExpression,
      cloneNode,
      expressionStatement,
      identifier,
      importDeclaration,
      importDefaultSpecifier,
      importNamespaceSpecifier,
      importSpecifier,
      memberExpression,
      stringLiteral,
      variableDeclaration,
      variableDeclarator
    } = _t;
    var ImportBuilder = class {
      constructor(importedSource, scope, hub) {
        this._statements = [];
        this._resultName = null;
        this._importedSource = void 0;
        this._scope = scope;
        this._hub = hub;
        this._importedSource = importedSource;
      }
      done() {
        return {
          statements: this._statements,
          resultName: this._resultName
        };
      }
      import() {
        this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));
        return this;
      }
      require() {
        this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)])));
        return this;
      }
      namespace(name = "namespace") {
        const local = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [importNamespaceSpecifier(local)];
        this._resultName = cloneNode(local);
        return this;
      }
      default(name) {
        const id = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [importDefaultSpecifier(id)];
        this._resultName = cloneNode(id);
        return this;
      }
      named(name, importName) {
        if (importName === "default")
          return this.default(name);
        const id = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [importSpecifier(id, identifier(importName))];
        this._resultName = cloneNode(id);
        return this;
      }
      var(name) {
        const id = this._scope.generateUidIdentifier(name);
        let statement = this._statements[this._statements.length - 1];
        if (statement.type !== "ExpressionStatement") {
          _assert(this._resultName);
          statement = expressionStatement(this._resultName);
          this._statements.push(statement);
        }
        this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(id, statement.expression)]);
        this._resultName = cloneNode(id);
        return this;
      }
      defaultInterop() {
        return this._interop(this._hub.addHelper("interopRequireDefault"));
      }
      wildcardInterop() {
        return this._interop(this._hub.addHelper("interopRequireWildcard"));
      }
      _interop(callee) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") {
          statement.expression = callExpression(callee, [statement.expression]);
        } else if (statement.type === "VariableDeclaration") {
          _assert(statement.declarations.length === 1);
          statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);
        } else {
          _assert.fail("Unexpected type.");
        }
        return this;
      }
      prop(name) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") {
          statement.expression = memberExpression(statement.expression, identifier(name));
        } else if (statement.type === "VariableDeclaration") {
          _assert(statement.declarations.length === 1);
          statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
        } else {
          _assert.fail("Unexpected type:" + statement.type);
        }
        return this;
      }
      read(name) {
        this._resultName = memberExpression(this._resultName, identifier(name));
      }
    };
    exports.default = ImportBuilder;
  }
});

// node_modules/@babel/helper-module-imports/lib/is-module.js
var require_is_module = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/is-module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isModule;
    function isModule(path) {
      const {
        sourceType
      } = path.node;
      if (sourceType !== "module" && sourceType !== "script") {
        throw path.buildCodeFrameError(`Unknown sourceType "${sourceType}", cannot transform.`);
      }
      return path.node.sourceType === "module";
    }
  }
});

// node_modules/@babel/helper-module-imports/lib/import-injector.js
var require_import_injector = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/import-injector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _assert = require_assert();
    var _t = require_lib5();
    var _importBuilder = require_import_builder();
    var _isModule = require_is_module();
    var {
      numericLiteral,
      sequenceExpression
    } = _t;
    var ImportInjector = class {
      constructor(path, importedSource, opts) {
        this._defaultOpts = {
          importedSource: null,
          importedType: "commonjs",
          importedInterop: "babel",
          importingInterop: "babel",
          ensureLiveReference: false,
          ensureNoContext: false,
          importPosition: "before"
        };
        const programPath = path.find((p) => p.isProgram());
        this._programPath = programPath;
        this._programScope = programPath.scope;
        this._hub = programPath.hub;
        this._defaultOpts = this._applyDefaults(importedSource, opts, true);
      }
      addDefault(importedSourceIn, opts) {
        return this.addNamed("default", importedSourceIn, opts);
      }
      addNamed(importName, importedSourceIn, opts) {
        _assert(typeof importName === "string");
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
      }
      addNamespace(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
      }
      addSideEffect(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
      }
      _applyDefaults(importedSource, opts, isInit = false) {
        let newOpts;
        if (typeof importedSource === "string") {
          newOpts = Object.assign({}, this._defaultOpts, {
            importedSource
          }, opts);
        } else {
          _assert(!opts, "Unexpected secondary arguments.");
          newOpts = Object.assign({}, this._defaultOpts, importedSource);
        }
        if (!isInit && opts) {
          if (opts.nameHint !== void 0)
            newOpts.nameHint = opts.nameHint;
          if (opts.blockHoist !== void 0)
            newOpts.blockHoist = opts.blockHoist;
        }
        return newOpts;
      }
      _generateImport(opts, importName) {
        const isDefault = importName === "default";
        const isNamed = !!importName && !isDefault;
        const isNamespace = importName === null;
        const {
          importedSource,
          importedType,
          importedInterop,
          importingInterop,
          ensureLiveReference,
          ensureNoContext,
          nameHint,
          importPosition,
          blockHoist
        } = opts;
        let name = nameHint || importName;
        const isMod = (0, _isModule.default)(this._programPath);
        const isModuleForNode = isMod && importingInterop === "node";
        const isModuleForBabel = isMod && importingInterop === "babel";
        if (importPosition === "after" && !isMod) {
          throw new Error(`"importPosition": "after" is only supported in modules`);
        }
        const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
        if (importedType === "es6") {
          if (!isModuleForNode && !isModuleForBabel) {
            throw new Error("Cannot import an ES6 module from CommonJS");
          }
          builder.import();
          if (isNamespace) {
            builder.namespace(nameHint || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else if (importedType !== "commonjs") {
          throw new Error(`Unexpected interopType "${importedType}"`);
        } else if (importedInterop === "babel") {
          if (isModuleForNode) {
            name = name !== "default" ? name : importedSource;
            const es6Default = `${importedSource}$es6Default`;
            builder.import();
            if (isNamespace) {
              builder.default(es6Default).var(name || importedSource).wildcardInterop();
            } else if (isDefault) {
              if (ensureLiveReference) {
                builder.default(es6Default).var(name || importedSource).defaultInterop().read("default");
              } else {
                builder.default(es6Default).var(name).defaultInterop().prop(importName);
              }
            } else if (isNamed) {
              builder.default(es6Default).read(importName);
            }
          } else if (isModuleForBabel) {
            builder.import();
            if (isNamespace) {
              builder.namespace(name || importedSource);
            } else if (isDefault || isNamed) {
              builder.named(name, importName);
            }
          } else {
            builder.require();
            if (isNamespace) {
              builder.var(name || importedSource).wildcardInterop();
            } else if ((isDefault || isNamed) && ensureLiveReference) {
              if (isDefault) {
                name = name !== "default" ? name : importedSource;
                builder.var(name).read(importName);
                builder.defaultInterop();
              } else {
                builder.var(importedSource).read(importName);
              }
            } else if (isDefault) {
              builder.var(name).defaultInterop().prop(importName);
            } else if (isNamed) {
              builder.var(name).prop(importName);
            }
          }
        } else if (importedInterop === "compiled") {
          if (isModuleForNode) {
            builder.import();
            if (isNamespace) {
              builder.default(name || importedSource);
            } else if (isDefault || isNamed) {
              builder.default(importedSource).read(name);
            }
          } else if (isModuleForBabel) {
            builder.import();
            if (isNamespace) {
              builder.namespace(name || importedSource);
            } else if (isDefault || isNamed) {
              builder.named(name, importName);
            }
          } else {
            builder.require();
            if (isNamespace) {
              builder.var(name || importedSource);
            } else if (isDefault || isNamed) {
              if (ensureLiveReference) {
                builder.var(importedSource).read(name);
              } else {
                builder.prop(importName).var(name);
              }
            }
          }
        } else if (importedInterop === "uncompiled") {
          if (isDefault && ensureLiveReference) {
            throw new Error("No live reference for commonjs default");
          }
          if (isModuleForNode) {
            builder.import();
            if (isNamespace) {
              builder.default(name || importedSource);
            } else if (isDefault) {
              builder.default(name);
            } else if (isNamed) {
              builder.default(importedSource).read(name);
            }
          } else if (isModuleForBabel) {
            builder.import();
            if (isNamespace) {
              builder.default(name || importedSource);
            } else if (isDefault) {
              builder.default(name);
            } else if (isNamed) {
              builder.named(name, importName);
            }
          } else {
            builder.require();
            if (isNamespace) {
              builder.var(name || importedSource);
            } else if (isDefault) {
              builder.var(name);
            } else if (isNamed) {
              if (ensureLiveReference) {
                builder.var(importedSource).read(name);
              } else {
                builder.var(name).prop(importName);
              }
            }
          }
        } else {
          throw new Error(`Unknown importedInterop "${importedInterop}".`);
        }
        const {
          statements,
          resultName
        } = builder.done();
        this._insertStatements(statements, importPosition, blockHoist);
        if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
          return sequenceExpression([numericLiteral(0), resultName]);
        }
        return resultName;
      }
      _insertStatements(statements, importPosition = "before", blockHoist = 3) {
        const body = this._programPath.get("body");
        if (importPosition === "after") {
          for (let i = body.length - 1; i >= 0; i--) {
            if (body[i].isImportDeclaration()) {
              body[i].insertAfter(statements);
              return;
            }
          }
        } else {
          statements.forEach((node) => {
            node._blockHoist = blockHoist;
          });
          const targetPath = body.find((p) => {
            const val = p.node._blockHoist;
            return Number.isFinite(val) && val < 4;
          });
          if (targetPath) {
            targetPath.insertBefore(statements);
            return;
          }
        }
        this._programPath.unshiftContainer("body", statements);
      }
    };
    exports.default = ImportInjector;
  }
});

// node_modules/@babel/helper-module-imports/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ImportInjector", {
      enumerable: true,
      get: function() {
        return _importInjector.default;
      }
    });
    exports.addDefault = addDefault;
    exports.addNamed = addNamed;
    exports.addNamespace = addNamespace;
    exports.addSideEffect = addSideEffect;
    Object.defineProperty(exports, "isModule", {
      enumerable: true,
      get: function() {
        return _isModule.default;
      }
    });
    var _importInjector = require_import_injector();
    var _isModule = require_is_module();
    function addDefault(path, importedSource, opts) {
      return new _importInjector.default(path).addDefault(importedSource, opts);
    }
    function addNamed(path, name, importedSource, opts) {
      return new _importInjector.default(path).addNamed(name, importedSource, opts);
    }
    function addNamespace(path, importedSource, opts) {
      return new _importInjector.default(path).addNamespace(importedSource, opts);
    }
    function addSideEffect(path, importedSource, opts) {
      return new _importInjector.default(path).addSideEffect(importedSource, opts);
    }
  }
});

// node_modules/@fortawesome/fontawesome-svg-core/import.macro.js
var require_import_macro = __commonJS({
  "node_modules/@fortawesome/fontawesome-svg-core/import.macro.js"(exports, module) {
    var { createMacro, MacroError } = require_dist2();
    var { addNamed } = require_lib6();
    module.exports = createMacro(importer, {
      configName: "fontawesome-svg-core"
    });
    var styles = [
      "solid",
      "regular",
      "light",
      "thin",
      "duotone",
      "brands"
    ];
    var macroNames = [
      ...styles,
      "icon"
    ];
    var families = [
      "classic",
      "duotone",
      "sharp"
    ];
    function importer({ references, state, babel, source, config }) {
      const license = config !== void 0 ? config.license : "free";
      if (!["free", "pro"].includes(license)) {
        throw new Error(
          "config license must be either 'free' or 'pro'"
        );
      }
      Object.keys(references).forEach((key) => {
        replace({
          macroName: key,
          license,
          references: references[key],
          state,
          babel,
          source
        });
      });
    }
    function replace({ macroName, license, references, state, babel, source }) {
      references.forEach((nodePath) => {
        const { iconName, style, family } = resolveReplacement({ nodePath, babel, state, macroName });
        const name = `fa${capitalize(camelCase(iconName))}`;
        const importFrom = getImport({ family, style, license, name });
        const importName = addNamed(nodePath, name, importFrom);
        nodePath.parentPath.replaceWith(importName);
      });
    }
    function getImport({ family, style, license, name }) {
      if (family) {
        return `@fortawesome/${family.toLowerCase()}-${style}-svg-icons/${name}`;
      } else if (style === "brands") {
        return `@fortawesome/free-brands-svg-icons/${name}`;
      } else {
        return `@fortawesome/${license}-${style}-svg-icons/${name}`;
      }
    }
    function resolveReplacement({ nodePath, babel, state, macroName }) {
      if ("icon" === macroName) {
        return resolveReplacementIcon({ nodePath, babel, state, macroName });
      } else {
        return resolveReplacementLegacyStyle({ nodePath, babel, state, macroName });
      }
    }
    function resolveReplacementLegacyStyle({ nodePath, babel, state, macroName }) {
      const { types: t } = babel;
      const { parentPath } = nodePath;
      if (!styles.includes(macroName)) {
        throw parentPath.buildCodeFrameError(
          `${macroName} is not a valid macro name. Use one of ${macroNames.join(", ")}`,
          MacroError
        );
      }
      if (parentPath.node.arguments) {
        if (parentPath.node.arguments.length < 1) {
          throw parentPath.buildCodeFrameError(
            `Received an invalid number of arguments for ${macroName} macro: must be exactly 1`,
            MacroError
          );
        }
        if (parentPath.node.arguments.length > 1) {
          throw parentPath.buildCodeFrameError(
            `Received an invalid number of arguments for ${macroName} macro: must be exactly 1`,
            MacroError
          );
        }
        if ((parentPath.node.arguments.length === 1 || parentPath.node.arguments.length === 2) && t.isStringLiteral(parentPath.node.arguments[0]) && nodePath.parentPath.node.arguments[0].value.startsWith("fa-")) {
          throw parentPath.buildCodeFrameError(
            `Don't begin the icon name with fa-, just use ${nodePath.parentPath.node.arguments[0].value.slice(3)}`,
            MacroError
          );
        }
        if ((parentPath.node.arguments.length === 1 || parentPath.node.arguments.length === 2) && !t.isStringLiteral(parentPath.node.arguments[0])) {
          throw parentPath.buildCodeFrameError(
            "Only string literals are supported when referencing icons (use a string here instead)",
            MacroError
          );
        }
      } else {
        throw parentPath.buildCodeFrameError(
          "Pass the icon name you would like to import as an argument.",
          MacroError
        );
      }
      return {
        iconName: nodePath.parentPath.node.arguments[0].value,
        style: macroName,
        family: void 0
      };
    }
    function resolveReplacementIcon({ nodePath, babel, state, macroName }) {
      const { types: t } = babel;
      const { parentPath } = nodePath;
      if ("icon" !== macroName) {
        throw parentPath.buildCodeFrameError(
          `${macroName} is not a valid macro name. Use one of ${macroNames.join(", ")}`,
          MacroError
        );
      }
      if (parentPath.node.arguments.length !== 1) {
        throw parentPath.buildCodeFrameError(
          `Received an invalid number of arguments for ${macroName} macro: must be exactly 1`,
          MacroError
        );
      }
      if (!t.isObjectExpression(parentPath.node.arguments[0])) {
        throw parentPath.buildCodeFrameError(
          "Only object expressions are supported when referencing icons with this macro, like this: { name: 'star' }",
          MacroError
        );
      }
      const properties = parentPath.node.arguments[0].properties || [];
      const namePropIndex = properties.findIndex((prop) => "name" === prop.key.name);
      const name = namePropIndex >= 0 ? getStringLiteralPropertyValue(t, parentPath, parentPath.node.arguments[0].properties[namePropIndex]) : void 0;
      if (!name) {
        throw parentPath.buildCodeFrameError(
          "The object argument to the icon() macro must have a name property",
          MacroError
        );
      }
      const stylePropIndex = properties.findIndex((prop) => "style" === prop.key.name);
      let style = stylePropIndex >= 0 ? getStringLiteralPropertyValue(t, parentPath, parentPath.node.arguments[0].properties[stylePropIndex]) : void 0;
      if (style && !styles.includes(style)) {
        throw parentPath.buildCodeFrameError(
          `Invalid style name: ${style}. It must be one of the following: ${styles.join(", ")}`,
          MacroError
        );
      }
      const familyPropIndex = properties.findIndex((prop) => "family" === prop.key.name);
      let family = familyPropIndex >= 0 ? getStringLiteralPropertyValue(t, parentPath, parentPath.node.arguments[0].properties[familyPropIndex]) : void 0;
      if (family && !families.includes(family)) {
        throw parentPath.buildCodeFrameError(
          `Invalid family name: ${family}. It must be one of the following: ${families.join(", ")}`,
          MacroError
        );
      }
      if ("duotone" === style && family && "classic" !== family) {
        throw parentPath.buildCodeFrameError(
          `duotone cannot be used as a style name with any family other than classic`,
          MacroError
        );
      }
      if ("brands" === style && family && "classic" !== family) {
        throw parentPath.buildCodeFrameError(
          `brands cannot be used as a style name with any family other than classic`,
          MacroError
        );
      }
      if (family && !style) {
        throw parentPath.buildCodeFrameError(
          `When a family is specified, a style must also be specified`,
          MacroError
        );
      }
      if ("duotone" === style || "duotone" === family) {
        family = void 0;
        style = "duotone";
      }
      if ("brands" === style) {
        family = void 0;
      }
      if (!style) {
        style = "solid";
      }
      if ("classic" === family) {
        family = void 0;
      }
      return {
        iconName: name,
        family,
        style
      };
    }
    function getStringLiteralPropertyValue(t, parentPath, property) {
      if (!("object" === typeof t && "function" === typeof t.isStringLiteral)) {
        throw Error("ERROR: invalid babel-types arg. This is probably a programming error in import.macro");
      }
      if (!("object" === typeof property && "object" === typeof property.value && "object" == typeof property.key)) {
        throw Error("ERROR: invalid babel property arg. This is probably a programming error in import.macro");
      }
      if (!("object" === typeof parentPath && "function" === typeof parentPath.buildCodeFrameError)) {
        throw Error("ERROR: invalid babel parentPath arg. This is probably a programming error in import.macro");
      }
      if (!t.isStringLiteral(property.value)) {
        throw parentPath.buildCodeFrameError(
          `Only string literals are supported for the ${property.key.name} property (use a string here instead)`,
          MacroError
        );
      }
      return property.value.value;
    }
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    function camelCase(str) {
      return str.split("-").map((s, index) => {
        return (index === 0 ? s[0].toLowerCase() : s[0].toUpperCase()) + s.slice(1).toLowerCase();
      }).join("");
    }
  }
});
export default require_import_macro();
//# sourceMappingURL=@fortawesome_fontawesome-svg-core_import__macro.js.map
